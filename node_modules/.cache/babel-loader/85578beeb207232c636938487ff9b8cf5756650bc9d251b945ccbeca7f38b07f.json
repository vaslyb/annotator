{"ast":null,"code":"// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n/**\n * @fileoverview Global |this| required for resolving indexes in node.\n * @suppress {globalThis}\n */\n(function (global) {\n  'use strict';\n\n  // If we're in node require encoding-indexes and attach it to the global.\n  if (typeof module !== \"undefined\" && module.exports && !global[\"encoding-indexes\"]) {\n    global[\"encoding-indexes\"] = require(\"./encoding-indexes.js\")[\"encoding-indexes\"];\n  }\n\n  //\n  // Utilities\n  //\n\n  /**\n   * @param {number} a The number to test.\n   * @param {number} min The minimum value in the range, inclusive.\n   * @param {number} max The maximum value in the range, inclusive.\n   * @return {boolean} True if a >= min and a <= max.\n   */\n  function inRange(a, min, max) {\n    return min <= a && a <= max;\n  }\n\n  /**\n   * @param {!Array.<*>} array The array to check.\n   * @param {*} item The item to look for in the array.\n   * @return {boolean} True if the item appears in the array.\n   */\n  function includes(array, item) {\n    return array.indexOf(item) !== -1;\n  }\n  var floor = Math.floor;\n\n  /**\n   * @param {*} o\n   * @return {Object}\n   */\n  function ToDictionary(o) {\n    if (o === undefined) return {};\n    if (o === Object(o)) return o;\n    throw TypeError('Could not convert argument to dictionary');\n  }\n\n  /**\n   * @param {string} string Input string of UTF-16 code units.\n   * @return {!Array.<number>} Code points.\n   */\n  function stringToCodePoints(string) {\n    // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n    // 1. Let S be the DOMString value.\n    var s = String(string);\n\n    // 2. Let n be the length of S.\n    var n = s.length;\n\n    // 3. Initialize i to 0.\n    var i = 0;\n\n    // 4. Initialize U to be an empty sequence of Unicode characters.\n    var u = [];\n\n    // 5. While i < n:\n    while (i < n) {\n      // 1. Let c be the code unit in S at index i.\n      var c = s.charCodeAt(i);\n\n      // 2. Depending on the value of c:\n\n      // c < 0xD800 or c > 0xDFFF\n      if (c < 0xD800 || c > 0xDFFF) {\n        // Append to U the Unicode character with code point c.\n        u.push(c);\n      }\n\n      // 0xDC00 ≤ c ≤ 0xDFFF\n      else if (0xDC00 <= c && c <= 0xDFFF) {\n        // Append to U a U+FFFD REPLACEMENT CHARACTER.\n        u.push(0xFFFD);\n      }\n\n      // 0xD800 ≤ c ≤ 0xDBFF\n      else if (0xD800 <= c && c <= 0xDBFF) {\n        // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n        // CHARACTER.\n        if (i === n - 1) {\n          u.push(0xFFFD);\n        }\n        // 2. Otherwise, i < n−1:\n        else {\n          // 1. Let d be the code unit in S at index i+1.\n          var d = s.charCodeAt(i + 1);\n\n          // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n          if (0xDC00 <= d && d <= 0xDFFF) {\n            // 1. Let a be c & 0x3FF.\n            var a = c & 0x3FF;\n\n            // 2. Let b be d & 0x3FF.\n            var b = d & 0x3FF;\n\n            // 3. Append to U the Unicode character with code point\n            // 2^16+2^10*a+b.\n            u.push(0x10000 + (a << 10) + b);\n\n            // 4. Set i to i+1.\n            i += 1;\n          }\n\n          // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n          // U+FFFD REPLACEMENT CHARACTER.\n          else {\n            u.push(0xFFFD);\n          }\n        }\n      }\n\n      // 3. Set i to i+1.\n      i += 1;\n    }\n\n    // 6. Return U.\n    return u;\n  }\n\n  /**\n   * @param {!Array.<number>} code_points Array of code points.\n   * @return {string} string String of UTF-16 code units.\n   */\n  function codePointsToString(code_points) {\n    var s = '';\n    for (var i = 0; i < code_points.length; ++i) {\n      var cp = code_points[i];\n      if (cp <= 0xFFFF) {\n        s += String.fromCharCode(cp);\n      } else {\n        cp -= 0x10000;\n        s += String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);\n      }\n    }\n    return s;\n  }\n\n  //\n  // Implementation of Encoding specification\n  // https://encoding.spec.whatwg.org/\n  //\n\n  //\n  // 4. Terminology\n  //\n\n  /**\n   * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n   * @param {number} a The number to test.\n   * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n   */\n  function isASCIIByte(a) {\n    return 0x00 <= a && a <= 0x7F;\n  }\n\n  /**\n   * An ASCII code point is a code point in the range U+0000 to\n   * U+007F, inclusive.\n   */\n  var isASCIICodePoint = isASCIIByte;\n\n  /**\n   * End-of-stream is a special token that signifies no more tokens\n   * are in the stream.\n   * @const\n   */\n  var end_of_stream = -1;\n\n  /**\n   * A stream represents an ordered sequence of tokens.\n   *\n   * @constructor\n   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n   * the stream.\n   */\n  function Stream(tokens) {\n    /** @type {!Array.<number>} */\n    this.tokens = [].slice.call(tokens);\n    // Reversed as push/pop is more efficient than shift/unshift.\n    this.tokens.reverse();\n  }\n  Stream.prototype = {\n    /**\n     * @return {boolean} True if end-of-stream has been hit.\n     */\n    endOfStream: function () {\n      return !this.tokens.length;\n    },\n    /**\n     * When a token is read from a stream, the first token in the\n     * stream must be returned and subsequently removed, and\n     * end-of-stream must be returned otherwise.\n     *\n     * @return {number} Get the next token from the stream, or\n     * end_of_stream.\n     */\n    read: function () {\n      if (!this.tokens.length) return end_of_stream;\n      return this.tokens.pop();\n    },\n    /**\n     * When one or more tokens are prepended to a stream, those tokens\n     * must be inserted, in given order, before the first token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n     * stream.\n     */\n    prepend: function (token) {\n      if (Array.isArray(token)) {\n        var tokens = /**@type {!Array.<number>}*/token;\n        while (tokens.length) this.tokens.push(tokens.pop());\n      } else {\n        this.tokens.push(token);\n      }\n    },\n    /**\n     * When one or more tokens are pushed to a stream, those tokens\n     * must be inserted, in given order, after the last token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n     * stream.\n     */\n    push: function (token) {\n      if (Array.isArray(token)) {\n        var tokens = /**@type {!Array.<number>}*/token;\n        while (tokens.length) this.tokens.unshift(tokens.shift());\n      } else {\n        this.tokens.unshift(token);\n      }\n    }\n  };\n\n  //\n  // 5. Encodings\n  //\n\n  // 5.1 Encoders and decoders\n\n  /** @const */\n  var finished = -1;\n\n  /**\n   * @param {boolean} fatal If true, decoding errors raise an exception.\n   * @param {number=} opt_code_point Override the standard fallback code point.\n   * @return {number} The code point to insert on a decoding error.\n   */\n  function decoderError(fatal, opt_code_point) {\n    if (fatal) throw TypeError('Decoder error');\n    return opt_code_point || 0xFFFD;\n  }\n\n  /**\n   * @param {number} code_point The code point that could not be encoded.\n   * @return {number} Always throws, no value is actually returned.\n   */\n  function encoderError(code_point) {\n    throw TypeError('The code point ' + code_point + ' could not be encoded.');\n  }\n\n  /** @interface */\n  function Decoder() {}\n  Decoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point, or |finished|.\n     */\n    handler: function (stream, bite) {}\n  };\n\n  /** @interface */\n  function Encoder() {}\n  Encoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of code points being encoded.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n     */\n    handler: function (stream, code_point) {}\n  };\n\n  // 5.2 Names and labels\n\n  // TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\n  // https://github.com/google/closure-compiler/issues/247\n\n  /**\n   * @param {string} label The encoding label.\n   * @return {?{name:string,labels:Array.<string>}}\n   */\n  function getEncoding(label) {\n    // 1. Remove any leading and trailing ASCII whitespace from label.\n    label = String(label).trim().toLowerCase();\n\n    // 2. If label is an ASCII case-insensitive match for any of the\n    // labels listed in the table below, return the corresponding\n    // encoding, and failure otherwise.\n    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n      return label_to_encoding[label];\n    }\n    return null;\n  }\n\n  /**\n   * Encodings table: https://encoding.spec.whatwg.org/encodings.json\n   * @const\n   * @type {!Array.<{\n   *          heading: string,\n   *          encodings: Array.<{name:string,labels:Array.<string>}>\n   *        }>}\n   */\n  var encodings = [{\n    \"encodings\": [{\n      \"labels\": [\"unicode-1-1-utf-8\", \"utf-8\", \"utf8\"],\n      \"name\": \"UTF-8\"\n    }],\n    \"heading\": \"The Encoding\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"866\", \"cp866\", \"csibm866\", \"ibm866\"],\n      \"name\": \"IBM866\"\n    }, {\n      \"labels\": [\"csisolatin2\", \"iso-8859-2\", \"iso-ir-101\", \"iso8859-2\", \"iso88592\", \"iso_8859-2\", \"iso_8859-2:1987\", \"l2\", \"latin2\"],\n      \"name\": \"ISO-8859-2\"\n    }, {\n      \"labels\": [\"csisolatin3\", \"iso-8859-3\", \"iso-ir-109\", \"iso8859-3\", \"iso88593\", \"iso_8859-3\", \"iso_8859-3:1988\", \"l3\", \"latin3\"],\n      \"name\": \"ISO-8859-3\"\n    }, {\n      \"labels\": [\"csisolatin4\", \"iso-8859-4\", \"iso-ir-110\", \"iso8859-4\", \"iso88594\", \"iso_8859-4\", \"iso_8859-4:1988\", \"l4\", \"latin4\"],\n      \"name\": \"ISO-8859-4\"\n    }, {\n      \"labels\": [\"csisolatincyrillic\", \"cyrillic\", \"iso-8859-5\", \"iso-ir-144\", \"iso8859-5\", \"iso88595\", \"iso_8859-5\", \"iso_8859-5:1988\"],\n      \"name\": \"ISO-8859-5\"\n    }, {\n      \"labels\": [\"arabic\", \"asmo-708\", \"csiso88596e\", \"csiso88596i\", \"csisolatinarabic\", \"ecma-114\", \"iso-8859-6\", \"iso-8859-6-e\", \"iso-8859-6-i\", \"iso-ir-127\", \"iso8859-6\", \"iso88596\", \"iso_8859-6\", \"iso_8859-6:1987\"],\n      \"name\": \"ISO-8859-6\"\n    }, {\n      \"labels\": [\"csisolatingreek\", \"ecma-118\", \"elot_928\", \"greek\", \"greek8\", \"iso-8859-7\", \"iso-ir-126\", \"iso8859-7\", \"iso88597\", \"iso_8859-7\", \"iso_8859-7:1987\", \"sun_eu_greek\"],\n      \"name\": \"ISO-8859-7\"\n    }, {\n      \"labels\": [\"csiso88598e\", \"csisolatinhebrew\", \"hebrew\", \"iso-8859-8\", \"iso-8859-8-e\", \"iso-ir-138\", \"iso8859-8\", \"iso88598\", \"iso_8859-8\", \"iso_8859-8:1988\", \"visual\"],\n      \"name\": \"ISO-8859-8\"\n    }, {\n      \"labels\": [\"csiso88598i\", \"iso-8859-8-i\", \"logical\"],\n      \"name\": \"ISO-8859-8-I\"\n    }, {\n      \"labels\": [\"csisolatin6\", \"iso-8859-10\", \"iso-ir-157\", \"iso8859-10\", \"iso885910\", \"l6\", \"latin6\"],\n      \"name\": \"ISO-8859-10\"\n    }, {\n      \"labels\": [\"iso-8859-13\", \"iso8859-13\", \"iso885913\"],\n      \"name\": \"ISO-8859-13\"\n    }, {\n      \"labels\": [\"iso-8859-14\", \"iso8859-14\", \"iso885914\"],\n      \"name\": \"ISO-8859-14\"\n    }, {\n      \"labels\": [\"csisolatin9\", \"iso-8859-15\", \"iso8859-15\", \"iso885915\", \"iso_8859-15\", \"l9\"],\n      \"name\": \"ISO-8859-15\"\n    }, {\n      \"labels\": [\"iso-8859-16\"],\n      \"name\": \"ISO-8859-16\"\n    }, {\n      \"labels\": [\"cskoi8r\", \"koi\", \"koi8\", \"koi8-r\", \"koi8_r\"],\n      \"name\": \"KOI8-R\"\n    }, {\n      \"labels\": [\"koi8-ru\", \"koi8-u\"],\n      \"name\": \"KOI8-U\"\n    }, {\n      \"labels\": [\"csmacintosh\", \"mac\", \"macintosh\", \"x-mac-roman\"],\n      \"name\": \"macintosh\"\n    }, {\n      \"labels\": [\"dos-874\", \"iso-8859-11\", \"iso8859-11\", \"iso885911\", \"tis-620\", \"windows-874\"],\n      \"name\": \"windows-874\"\n    }, {\n      \"labels\": [\"cp1250\", \"windows-1250\", \"x-cp1250\"],\n      \"name\": \"windows-1250\"\n    }, {\n      \"labels\": [\"cp1251\", \"windows-1251\", \"x-cp1251\"],\n      \"name\": \"windows-1251\"\n    }, {\n      \"labels\": [\"ansi_x3.4-1968\", \"ascii\", \"cp1252\", \"cp819\", \"csisolatin1\", \"ibm819\", \"iso-8859-1\", \"iso-ir-100\", \"iso8859-1\", \"iso88591\", \"iso_8859-1\", \"iso_8859-1:1987\", \"l1\", \"latin1\", \"us-ascii\", \"windows-1252\", \"x-cp1252\"],\n      \"name\": \"windows-1252\"\n    }, {\n      \"labels\": [\"cp1253\", \"windows-1253\", \"x-cp1253\"],\n      \"name\": \"windows-1253\"\n    }, {\n      \"labels\": [\"cp1254\", \"csisolatin5\", \"iso-8859-9\", \"iso-ir-148\", \"iso8859-9\", \"iso88599\", \"iso_8859-9\", \"iso_8859-9:1989\", \"l5\", \"latin5\", \"windows-1254\", \"x-cp1254\"],\n      \"name\": \"windows-1254\"\n    }, {\n      \"labels\": [\"cp1255\", \"windows-1255\", \"x-cp1255\"],\n      \"name\": \"windows-1255\"\n    }, {\n      \"labels\": [\"cp1256\", \"windows-1256\", \"x-cp1256\"],\n      \"name\": \"windows-1256\"\n    }, {\n      \"labels\": [\"cp1257\", \"windows-1257\", \"x-cp1257\"],\n      \"name\": \"windows-1257\"\n    }, {\n      \"labels\": [\"cp1258\", \"windows-1258\", \"x-cp1258\"],\n      \"name\": \"windows-1258\"\n    }, {\n      \"labels\": [\"x-mac-cyrillic\", \"x-mac-ukrainian\"],\n      \"name\": \"x-mac-cyrillic\"\n    }],\n    \"heading\": \"Legacy single-byte encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"chinese\", \"csgb2312\", \"csiso58gb231280\", \"gb2312\", \"gb_2312\", \"gb_2312-80\", \"gbk\", \"iso-ir-58\", \"x-gbk\"],\n      \"name\": \"GBK\"\n    }, {\n      \"labels\": [\"gb18030\"],\n      \"name\": \"gb18030\"\n    }],\n    \"heading\": \"Legacy multi-byte Chinese (simplified) encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"big5\", \"big5-hkscs\", \"cn-big5\", \"csbig5\", \"x-x-big5\"],\n      \"name\": \"Big5\"\n    }],\n    \"heading\": \"Legacy multi-byte Chinese (traditional) encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"cseucpkdfmtjapanese\", \"euc-jp\", \"x-euc-jp\"],\n      \"name\": \"EUC-JP\"\n    }, {\n      \"labels\": [\"csiso2022jp\", \"iso-2022-jp\"],\n      \"name\": \"ISO-2022-JP\"\n    }, {\n      \"labels\": [\"csshiftjis\", \"ms932\", \"ms_kanji\", \"shift-jis\", \"shift_jis\", \"sjis\", \"windows-31j\", \"x-sjis\"],\n      \"name\": \"Shift_JIS\"\n    }],\n    \"heading\": \"Legacy multi-byte Japanese encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"cseuckr\", \"csksc56011987\", \"euc-kr\", \"iso-ir-149\", \"korean\", \"ks_c_5601-1987\", \"ks_c_5601-1989\", \"ksc5601\", \"ksc_5601\", \"windows-949\"],\n      \"name\": \"EUC-KR\"\n    }],\n    \"heading\": \"Legacy multi-byte Korean encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"csiso2022kr\", \"hz-gb-2312\", \"iso-2022-cn\", \"iso-2022-cn-ext\", \"iso-2022-kr\"],\n      \"name\": \"replacement\"\n    }, {\n      \"labels\": [\"utf-16be\"],\n      \"name\": \"UTF-16BE\"\n    }, {\n      \"labels\": [\"utf-16\", \"utf-16le\"],\n      \"name\": \"UTF-16LE\"\n    }, {\n      \"labels\": [\"x-user-defined\"],\n      \"name\": \"x-user-defined\"\n    }],\n    \"heading\": \"Legacy miscellaneous encodings\"\n  }];\n\n  // Label to encoding registry.\n  /** @type {Object.<string,{name:string,labels:Array.<string>}>} */\n  var label_to_encoding = {};\n  encodings.forEach(function (category) {\n    category.encodings.forEach(function (encoding) {\n      encoding.labels.forEach(function (label) {\n        label_to_encoding[label] = encoding;\n      });\n    });\n  });\n\n  // Registry of of encoder/decoder factories, by encoding name.\n  /** @type {Object.<string, function({fatal:boolean}): Encoder>} */\n  var encoders = {};\n  /** @type {Object.<string, function({fatal:boolean}): Decoder>} */\n  var decoders = {};\n\n  //\n  // 6. Indexes\n  //\n\n  /**\n   * @param {number} pointer The |pointer| to search for.\n   * @param {(!Array.<?number>|undefined)} index The |index| to search within.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in |index|.\n   */\n  function indexCodePointFor(pointer, index) {\n    if (!index) return null;\n    return index[pointer] || null;\n  }\n\n  /**\n   * @param {number} code_point The |code point| to search for.\n   * @param {!Array.<?number>} index The |index| to search within.\n   * @return {?number} The first pointer corresponding to |code point| in\n   *     |index|, or null if |code point| is not in |index|.\n   */\n  function indexPointerFor(code_point, index) {\n    var pointer = index.indexOf(code_point);\n    return pointer === -1 ? null : pointer;\n  }\n\n  /**\n   * @param {string} name Name of the index.\n   * @return {(!Array.<number>|!Array.<Array.<number>>)}\n   *  */\n  function index(name) {\n    if (!('encoding-indexes' in global)) {\n      throw Error(\"Indexes missing.\" + \" Did you forget to include encoding-indexes.js first?\");\n    }\n    return global['encoding-indexes'][name];\n  }\n\n  /**\n   * @param {number} pointer The |pointer| to search for in the gb18030 index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the gb18030 index.\n   */\n  function indexGB18030RangesCodePointFor(pointer) {\n    // 1. If pointer is greater than 39419 and less than 189000, or\n    // pointer is greater than 1237575, return null.\n    if (pointer > 39419 && pointer < 189000 || pointer > 1237575) return null;\n\n    // 2. If pointer is 7457, return code point U+E7C7.\n    if (pointer === 7457) return 0xE7C7;\n\n    // 3. Let offset be the last pointer in index gb18030 ranges that\n    // is equal to or less than pointer and let code point offset be\n    // its corresponding code point.\n    var offset = 0;\n    var code_point_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n      if (entry[0] <= pointer) {\n        offset = entry[0];\n        code_point_offset = entry[1];\n      } else {\n        break;\n      }\n    }\n\n    // 4. Return a code point whose value is code point offset +\n    // pointer − offset.\n    return code_point_offset + pointer - offset;\n  }\n\n  /**\n   * @param {number} code_point The |code point| to locate in the gb18030 index.\n   * @return {number} The first pointer corresponding to |code point| in the\n   *     gb18030 index.\n   */\n  function indexGB18030RangesPointerFor(code_point) {\n    // 1. If code point is U+E7C7, return pointer 7457.\n    if (code_point === 0xE7C7) return 7457;\n\n    // 2. Let offset be the last code point in index gb18030 ranges\n    // that is equal to or less than code point and let pointer offset\n    // be its corresponding pointer.\n    var offset = 0;\n    var pointer_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n      if (entry[1] <= code_point) {\n        offset = entry[1];\n        pointer_offset = entry[0];\n      } else {\n        break;\n      }\n    }\n\n    // 3. Return a pointer whose value is pointer offset + code point\n    // − offset.\n    return pointer_offset + code_point - offset;\n  }\n\n  /**\n   * @param {number} code_point The |code_point| to search for in the Shift_JIS\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the Shift_JIS index.\n   */\n  function indexShiftJISPointerFor(code_point) {\n    // 1. Let index be index jis0208 excluding all entries whose\n    // pointer is in the range 8272 to 8835, inclusive.\n    shift_jis_index = shift_jis_index || index('jis0208').map(function (code_point, pointer) {\n      return inRange(pointer, 8272, 8835) ? null : code_point;\n    });\n    var index_ = shift_jis_index;\n\n    // 2. Return the index pointer for code point in index.\n    return index_.indexOf(code_point);\n  }\n  var shift_jis_index;\n\n  /**\n   * @param {number} code_point The |code_point| to search for in the big5\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the big5 index.\n   */\n  function indexBig5PointerFor(code_point) {\n    // 1. Let index be index Big5 excluding all entries whose pointer\n    big5_index_no_hkscs = big5_index_no_hkscs || index('big5').map(function (code_point, pointer) {\n      return pointer < (0xA1 - 0x81) * 157 ? null : code_point;\n    });\n    var index_ = big5_index_no_hkscs;\n\n    // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\n    // U+5345, return the last pointer corresponding to code point in\n    // index.\n    if (code_point === 0x2550 || code_point === 0x255E || code_point === 0x2561 || code_point === 0x256A || code_point === 0x5341 || code_point === 0x5345) {\n      return index_.lastIndexOf(code_point);\n    }\n\n    // 3. Return the index pointer for code point in index.\n    return indexPointerFor(code_point, index_);\n  }\n  var big5_index_no_hkscs;\n\n  //\n  // 8. API\n  //\n\n  /** @const */\n  var DEFAULT_ENCODING = 'utf-8';\n\n  // 8.1 Interface TextDecoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding;\n   *     defaults to 'utf-8'.\n   * @param {Object=} options\n   */\n  function TextDecoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextDecoder)) throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n    options = ToDictionary(options);\n\n    // A TextDecoder object has an associated encoding, decoder,\n    // stream, ignore BOM flag (initially unset), BOM seen flag\n    // (initially unset), error mode (initially replacement), and do\n    // not flush flag (initially unset).\n\n    /** @private */\n    this._encoding = null;\n    /** @private @type {?Decoder} */\n    this._decoder = null;\n    /** @private @type {boolean} */\n    this._ignoreBOM = false;\n    /** @private @type {boolean} */\n    this._BOMseen = false;\n    /** @private @type {string} */\n    this._error_mode = 'replacement';\n    /** @private @type {boolean} */\n    this._do_not_flush = false;\n\n    // 1. Let encoding be the result of getting an encoding from\n    // label.\n    var encoding = getEncoding(label);\n\n    // 2. If encoding is failure or replacement, throw a RangeError.\n    if (encoding === null || encoding.name === 'replacement') throw RangeError('Unknown encoding: ' + label);\n    if (!decoders[encoding.name]) {\n      throw Error('Decoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n    }\n\n    // 3. Let dec be a new TextDecoder object.\n    var dec = this;\n\n    // 4. Set dec's encoding to encoding.\n    dec._encoding = encoding;\n\n    // 5. If options's fatal member is true, set dec's error mode to\n    // fatal.\n    if (Boolean(options['fatal'])) dec._error_mode = 'fatal';\n\n    // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n    // flag.\n    if (Boolean(options['ignoreBOM'])) dec._ignoreBOM = true;\n\n    // For pre-ES5 runtimes:\n    if (!Object.defineProperty) {\n      this.encoding = dec._encoding.name.toLowerCase();\n      this.fatal = dec._error_mode === 'fatal';\n      this.ignoreBOM = dec._ignoreBOM;\n    }\n\n    // 7. Return dec.\n    return dec;\n  }\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextDecoder.prototype, 'encoding', {\n      /** @this {TextDecoder} */\n      get: function () {\n        return this._encoding.name.toLowerCase();\n      }\n    });\n\n    // The fatal attribute's getter must return true if error mode\n    // is fatal, and false otherwise.\n    Object.defineProperty(TextDecoder.prototype, 'fatal', {\n      /** @this {TextDecoder} */\n      get: function () {\n        return this._error_mode === 'fatal';\n      }\n    });\n\n    // The ignoreBOM attribute's getter must return true if ignore\n    // BOM flag is set, and false otherwise.\n    Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {\n      /** @this {TextDecoder} */\n      get: function () {\n        return this._ignoreBOM;\n      }\n    });\n  }\n\n  /**\n   * @param {BufferSource=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  TextDecoder.prototype.decode = function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input && input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n    options = ToDictionary(options);\n\n    // 1. If the do not flush flag is unset, set decoder to a new\n    // encoding's decoder, set stream to a new stream, and unset the\n    // BOM seen flag.\n    if (!this._do_not_flush) {\n      this._decoder = decoders[this._encoding.name]({\n        fatal: this._error_mode === 'fatal'\n      });\n      this._BOMseen = false;\n    }\n\n    // 2. If options's stream is true, set the do not flush flag, and\n    // unset the do not flush flag otherwise.\n    this._do_not_flush = Boolean(options['stream']);\n\n    // 3. If input is given, push a copy of input to stream.\n    // TODO: Align with spec algorithm - maintain stream on instance.\n    var input_stream = new Stream(bytes);\n\n    // 4. Let output be a new stream.\n    var output = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    // 5. While true:\n    while (true) {\n      // 1. Let token be the result of reading from stream.\n      var token = input_stream.read();\n\n      // 2. If token is end-of-stream and the do not flush flag is\n      // set, return output, serialized.\n      // TODO: Align with spec algorithm.\n      if (token === end_of_stream) break;\n\n      // 3. Otherwise, run these subsubsteps:\n\n      // 1. Let result be the result of processing token for decoder,\n      // stream, output, and error mode.\n      result = this._decoder.handler(input_stream, token);\n\n      // 2. If result is finished, return output, serialized.\n      if (result === finished) break;\n      if (result !== null) {\n        if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);\n      }\n\n      // 3. Otherwise, if result is error, throw a TypeError.\n      // (Thrown in handler)\n\n      // 4. Otherwise, do nothing.\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished) break;\n        if (result === null) continue;\n        if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    // A TextDecoder object also has an associated serialize stream\n    // algorithm...\n    /**\n     * @param {!Array.<number>} stream\n     * @return {string}\n     * @this {TextDecoder}\n     */\n    function serializeStream(stream) {\n      // 1. Let token be the result of reading from stream.\n      // (Done in-place on array, rather than as a stream)\n\n      // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n      // BOM flag and BOM seen flag are unset, run these subsubsteps:\n      if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) && !this._ignoreBOM && !this._BOMseen) {\n        if (stream.length > 0 && stream[0] === 0xFEFF) {\n          // 1. If token is U+FEFF, set BOM seen flag.\n          this._BOMseen = true;\n          stream.shift();\n        } else if (stream.length > 0) {\n          // 2. Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to stream.\n          this._BOMseen = true;\n        } else {\n          // 3. Otherwise, if token is not end-of-stream, append token\n          // to output.\n          // (no-op)\n        }\n      }\n      // 4. Otherwise, return output.\n      return codePointsToString(stream);\n    }\n    return serializeStream.call(this, output);\n  };\n\n  // 8.2 Interface TextEncoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding. NONSTANDARD.\n   * @param {Object=} options NONSTANDARD.\n   */\n  function TextEncoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextEncoder)) throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    options = ToDictionary(options);\n\n    // A TextEncoder object has an associated encoding and encoder.\n\n    /** @private */\n    this._encoding = null;\n    /** @private @type {?Encoder} */\n    this._encoder = null;\n\n    // Non-standard\n    /** @private @type {boolean} */\n    this._do_not_flush = false;\n    /** @private @type {string} */\n    this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';\n\n    // 1. Let enc be a new TextEncoder object.\n    var enc = this;\n\n    // 2. Set enc's encoding to UTF-8's encoder.\n    if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {\n      // NONSTANDARD behavior.\n      label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n      var encoding = getEncoding(label);\n      if (encoding === null || encoding.name === 'replacement') throw RangeError('Unknown encoding: ' + label);\n      if (!encoders[encoding.name]) {\n        throw Error('Encoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n      }\n      enc._encoding = encoding;\n    } else {\n      // Standard behavior.\n      enc._encoding = getEncoding('utf-8');\n      if (label !== undefined && 'console' in global) {\n        console.warn('TextEncoder constructor called with encoding label, ' + 'which is ignored.');\n      }\n    }\n\n    // For pre-ES5 runtimes:\n    if (!Object.defineProperty) this.encoding = enc._encoding.name.toLowerCase();\n\n    // 3. Return enc.\n    return enc;\n  }\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextEncoder.prototype, 'encoding', {\n      /** @this {TextEncoder} */\n      get: function () {\n        return this._encoding.name.toLowerCase();\n      }\n    });\n  }\n\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {!Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  TextEncoder.prototype.encode = function encode(opt_string, options) {\n    opt_string = opt_string === undefined ? '' : String(opt_string);\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\n    // the input is a USVString so streaming is not necessary.\n    if (!this._do_not_flush) this._encoder = encoders[this._encoding.name]({\n      fatal: this._fatal === 'fatal'\n    });\n    this._do_not_flush = Boolean(options['stream']);\n\n    // 1. Convert input to a stream.\n    var input = new Stream(stringToCodePoints(opt_string));\n\n    // 2. Let output be a new stream\n    var output = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    // 3. While true, run these substeps:\n    while (true) {\n      // 1. Let token be the result of reading from input.\n      var token = input.read();\n      if (token === end_of_stream) break;\n      // 2. Let result be the result of processing token for encoder,\n      // input, output.\n      result = this._encoder.handler(input, token);\n      if (result === finished) break;\n      if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      while (true) {\n        result = this._encoder.handler(input, input.read());\n        if (result === finished) break;\n        if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);\n      }\n      this._encoder = null;\n    }\n    // 3. If result is finished, convert output into a byte sequence,\n    // and then return a Uint8Array object wrapping an ArrayBuffer\n    // containing output.\n    return new Uint8Array(output);\n  };\n\n  //\n  // 9. The encoding\n  //\n\n  // 9.1 utf-8\n\n  // 9.1.1 utf-8 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function UTF8Decoder(options) {\n    var fatal = options.fatal;\n\n    // utf-8's decoder's has an associated utf-8 code point, utf-8\n    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n    // lower boundary (initially 0x80), and a utf-8 upper boundary\n    // (initially 0xBF).\n    var /** @type {number} */utf8_code_point = 0,\n      /** @type {number} */utf8_bytes_seen = 0,\n      /** @type {number} */utf8_bytes_needed = 0,\n      /** @type {number} */utf8_lower_boundary = 0x80,\n      /** @type {number} */utf8_upper_boundary = 0xBF;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n      // set utf-8 bytes needed to 0 and return error.\n      if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n        utf8_bytes_needed = 0;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream) return finished;\n\n      // 3. If utf-8 bytes needed is 0, based on byte:\n      if (utf8_bytes_needed === 0) {\n        // 0x00 to 0x7F\n        if (inRange(bite, 0x00, 0x7F)) {\n          // Return a code point whose value is byte.\n          return bite;\n        }\n\n        // 0xC2 to 0xDF\n        else if (inRange(bite, 0xC2, 0xDF)) {\n          // 1. Set utf-8 bytes needed to 1.\n          utf8_bytes_needed = 1;\n\n          // 2. Set UTF-8 code point to byte & 0x1F.\n          utf8_code_point = bite & 0x1F;\n        }\n\n        // 0xE0 to 0xEF\n        else if (inRange(bite, 0xE0, 0xEF)) {\n          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n          if (bite === 0xE0) utf8_lower_boundary = 0xA0;\n          // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n          if (bite === 0xED) utf8_upper_boundary = 0x9F;\n          // 3. Set utf-8 bytes needed to 2.\n          utf8_bytes_needed = 2;\n          // 4. Set UTF-8 code point to byte & 0xF.\n          utf8_code_point = bite & 0xF;\n        }\n\n        // 0xF0 to 0xF4\n        else if (inRange(bite, 0xF0, 0xF4)) {\n          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n          if (bite === 0xF0) utf8_lower_boundary = 0x90;\n          // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n          if (bite === 0xF4) utf8_upper_boundary = 0x8F;\n          // 3. Set utf-8 bytes needed to 3.\n          utf8_bytes_needed = 3;\n          // 4. Set UTF-8 code point to byte & 0x7.\n          utf8_code_point = bite & 0x7;\n        }\n\n        // Otherwise\n        else {\n          // Return error.\n          return decoderError(fatal);\n        }\n\n        // Return continue.\n        return null;\n      }\n\n      // 4. If byte is not in the range utf-8 lower boundary to utf-8\n      // upper boundary, inclusive, run these substeps:\n      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n        // utf-8 upper boundary to 0xBF.\n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n        utf8_lower_boundary = 0x80;\n        utf8_upper_boundary = 0xBF;\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Return error.\n        return decoderError(fatal);\n      }\n\n      // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n      // to 0xBF.\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n      // 0x3F)\n      utf8_code_point = utf8_code_point << 6 | bite & 0x3F;\n\n      // 7. Increase utf-8 bytes seen by one.\n      utf8_bytes_seen += 1;\n\n      // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n      // continue.\n      if (utf8_bytes_seen !== utf8_bytes_needed) return null;\n\n      // 9. Let code point be utf-8 code point.\n      var code_point = utf8_code_point;\n\n      // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n      // seen to 0.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n      // 11. Return a code point whose value is code point.\n      return code_point;\n    };\n  }\n\n  // 9.1.2 utf-8 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function UTF8Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 3. Set count and offset based on the range code point is in:\n      var count, offset;\n      // U+0080 to U+07FF, inclusive:\n      if (inRange(code_point, 0x0080, 0x07FF)) {\n        // 1 and 0xC0\n        count = 1;\n        offset = 0xC0;\n      }\n      // U+0800 to U+FFFF, inclusive:\n      else if (inRange(code_point, 0x0800, 0xFFFF)) {\n        // 2 and 0xE0\n        count = 2;\n        offset = 0xE0;\n      }\n      // U+10000 to U+10FFFF, inclusive:\n      else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n        // 3 and 0xF0\n        count = 3;\n        offset = 0xF0;\n      }\n\n      // 4. Let bytes be a byte sequence whose first byte is (code\n      // point >> (6 × count)) + offset.\n      var bytes = [(code_point >> 6 * count) + offset];\n\n      // 5. Run these substeps while count is greater than 0:\n      while (count > 0) {\n        // 1. Set temp to code point >> (6 × (count − 1)).\n        var temp = code_point >> 6 * (count - 1);\n\n        // 2. Append to bytes 0x80 | (temp & 0x3F).\n        bytes.push(0x80 | temp & 0x3F);\n\n        // 3. Decrease count by one.\n        count -= 1;\n      }\n\n      // 6. Return bytes bytes, in order.\n      return bytes;\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-8'] = function (options) {\n    return new UTF8Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-8'] = function (options) {\n    return new UTF8Decoder(options);\n  };\n\n  //\n  // 10. Legacy single-byte encodings\n  //\n\n  // 10.1 single-byte decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {!Array.<number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  function SingleByteDecoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream) return finished;\n\n      // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite)) return bite;\n\n      // 3. Let code point be the index code point for byte − 0x80 in\n      // index single-byte.\n      var code_point = index[bite - 0x80];\n\n      // 4. If code point is null, return error.\n      if (code_point === null) return decoderError(fatal);\n\n      // 5. Return a code point whose value is code point.\n      return code_point;\n    };\n  }\n\n  // 10.2 single-byte encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {!Array.<?number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  function SingleByteEncoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 3. Let pointer be the index pointer for code point in index\n      // single-byte.\n      var pointer = indexPointerFor(code_point, index);\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null) encoderError(code_point);\n\n      // 5. Return a byte whose value is pointer + 0x80.\n      return pointer + 0x80;\n    };\n  }\n  (function () {\n    if (!('encoding-indexes' in global)) return;\n    encodings.forEach(function (category) {\n      if (category.heading !== 'Legacy single-byte encodings') return;\n      category.encodings.forEach(function (encoding) {\n        var name = encoding.name;\n        var idx = index(name.toLowerCase());\n        /** @param {{fatal: boolean}} options */\n        decoders[name] = function (options) {\n          return new SingleByteDecoder(idx, options);\n        };\n        /** @param {{fatal: boolean}} options */\n        encoders[name] = function (options) {\n          return new SingleByteEncoder(idx, options);\n        };\n      });\n    });\n  })();\n\n  //\n  // 11. Legacy multi-byte Chinese (simplified) encodings\n  //\n\n  // 11.1 gbk\n\n  // 11.1.1 gbk decoder\n  // gbk's decoder is gb18030's decoder.\n  /** @param {{fatal: boolean}} options */\n  decoders['GBK'] = function (options) {\n    return new GB18030Decoder(options);\n  };\n\n  // 11.1.2 gbk encoder\n  // gbk's encoder is gb18030's encoder with its gbk flag set.\n  /** @param {{fatal: boolean}} options */\n  encoders['GBK'] = function (options) {\n    return new GB18030Encoder(options, true);\n  };\n\n  // 11.2 gb18030\n\n  // 11.2.1 gb18030 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function GB18030Decoder(options) {\n    var fatal = options.fatal;\n    // gb18030's decoder has an associated gb18030 first, gb18030\n    // second, and gb18030 third (all initially 0x00).\n    var /** @type {number} */gb18030_first = 0x00,\n      /** @type {number} */gb18030_second = 0x00,\n      /** @type {number} */gb18030_third = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and gb18030 first, gb18030\n      // second, and gb18030 third are 0x00, return finished.\n      if (bite === end_of_stream && gb18030_first === 0x00 && gb18030_second === 0x00 && gb18030_third === 0x00) {\n        return finished;\n      }\n      // 2. If byte is end-of-stream, and gb18030 first, gb18030\n      // second, or gb18030 third is not 0x00, set gb18030 first,\n      // gb18030 second, and gb18030 third to 0x00, and return error.\n      if (bite === end_of_stream && (gb18030_first !== 0x00 || gb18030_second !== 0x00 || gb18030_third !== 0x00)) {\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n        decoderError(fatal);\n      }\n      var code_point;\n      // 3. If gb18030 third is not 0x00, run these substeps:\n      if (gb18030_third !== 0x00) {\n        // 1. Let code point be null.\n        code_point = null;\n        // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n        // code point to the index gb18030 ranges code point for\n        // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×\n        // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.\n        if (inRange(bite, 0x30, 0x39)) {\n          code_point = indexGB18030RangesCodePointFor((((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 + gb18030_third - 0x81) * 10 + bite - 0x30);\n        }\n\n        // 3. Let buffer be a byte sequence consisting of gb18030\n        // second, gb18030 third, and byte, in order.\n        var buffer = [gb18030_second, gb18030_third, bite];\n\n        // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n        // 0x00.\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n\n        // 5. If code point is null, prepend buffer to stream and\n        // return error.\n        if (code_point === null) {\n          stream.prepend(buffer);\n          return decoderError(fatal);\n        }\n\n        // 6. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If gb18030 second is not 0x00, run these substeps:\n      if (gb18030_second !== 0x00) {\n        // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n        // gb18030 third to byte and return continue.\n        if (inRange(bite, 0x81, 0xFE)) {\n          gb18030_third = bite;\n          return null;\n        }\n\n        // 2. Prepend gb18030 second followed by byte to stream, set\n        // gb18030 first and gb18030 second to 0x00, and return error.\n        stream.prepend([gb18030_second, bite]);\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 5. If gb18030 first is not 0x00, run these substeps:\n      if (gb18030_first !== 0x00) {\n        // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n        // gb18030 second to byte and return continue.\n        if (inRange(bite, 0x30, 0x39)) {\n          gb18030_second = bite;\n          return null;\n        }\n\n        // 2. Let lead be gb18030 first, let pointer be null, and set\n        // gb18030 first to 0x00.\n        var lead = gb18030_first;\n        var pointer = null;\n        gb18030_first = 0x00;\n\n        // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n        // otherwise.\n        var offset = bite < 0x7F ? 0x40 : 0x41;\n\n        // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +\n        // (byte − offset).\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE)) pointer = (lead - 0x81) * 190 + (bite - offset);\n\n        // 5. Let code point be null if pointer is null and the index\n        // code point for pointer in index gb18030 otherwise.\n        code_point = pointer === null ? null : indexCodePointFor(pointer, index('gb18030'));\n\n        // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n        // 7. If code point is null, return error.\n        if (code_point === null) return decoderError(fatal);\n\n        // 8. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite)) return bite;\n\n      // 7. If byte is 0x80, return code point U+20AC.\n      if (bite === 0x80) return 0x20AC;\n\n      // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 first to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        gb18030_first = bite;\n        return null;\n      }\n\n      // 9. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 11.2.2 gb18030 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   * @param {boolean=} gbk_flag\n   */\n  function GB18030Encoder(options, gbk_flag) {\n    var fatal = options.fatal;\n    // gb18030's decoder has an associated gbk flag (initially unset).\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 3. If code point is U+E5E5, return error with code point.\n      if (code_point === 0xE5E5) return encoderError(code_point);\n\n      // 4. If the gbk flag is set and code point is U+20AC, return\n      // byte 0x80.\n      if (gbk_flag && code_point === 0x20AC) return 0x80;\n\n      // 5. Let pointer be the index pointer for code point in index\n      // gb18030.\n      var pointer = indexPointerFor(code_point, index('gb18030'));\n\n      // 6. If pointer is not null, run these substeps:\n      if (pointer !== null) {\n        // 1. Let lead be floor(pointer / 190) + 0x81.\n        var lead = floor(pointer / 190) + 0x81;\n\n        // 2. Let trail be pointer % 190.\n        var trail = pointer % 190;\n\n        // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n        var offset = trail < 0x3F ? 0x40 : 0x41;\n\n        // 4. Return two bytes whose values are lead and trail + offset.\n        return [lead, trail + offset];\n      }\n\n      // 7. If gbk flag is set, return error with code point.\n      if (gbk_flag) return encoderError(code_point);\n\n      // 8. Set pointer to the index gb18030 ranges pointer for code\n      // point.\n      pointer = indexGB18030RangesPointerFor(code_point);\n\n      // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n      var byte1 = floor(pointer / 10 / 126 / 10);\n\n      // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\n      pointer = pointer - byte1 * 10 * 126 * 10;\n\n      // 11. Let byte2 be floor(pointer / 10 / 126).\n      var byte2 = floor(pointer / 10 / 126);\n\n      // 12. Set pointer to pointer − byte2 × 10 × 126.\n      pointer = pointer - byte2 * 10 * 126;\n\n      // 13. Let byte3 be floor(pointer / 10).\n      var byte3 = floor(pointer / 10);\n\n      // 14. Let byte4 be pointer − byte3 × 10.\n      var byte4 = pointer - byte3 * 10;\n\n      // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n      // 0x30, byte3 + 0x81, byte4 + 0x30.\n      return [byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['gb18030'] = function (options) {\n    return new GB18030Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['gb18030'] = function (options) {\n    return new GB18030Decoder(options);\n  };\n\n  //\n  // 12. Legacy multi-byte Chinese (traditional) encodings\n  //\n\n  // 12.1 Big5\n\n  // 12.1.1 Big5 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function Big5Decoder(options) {\n    var fatal = options.fatal;\n    // Big5's decoder has an associated Big5 lead (initially 0x00).\n    var /** @type {number} */Big5_lead = 0x00;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n      // Big5 lead to 0x00 and return error.\n      if (bite === end_of_stream && Big5_lead !== 0x00) {\n        Big5_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && Big5_lead === 0x00) return finished;\n\n      // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n      // pointer be null, set Big5 lead to 0x00, and then run these\n      // substeps:\n      if (Big5_lead !== 0x00) {\n        var lead = Big5_lead;\n        var pointer = null;\n        Big5_lead = 0x00;\n\n        // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n        // otherwise.\n        var offset = bite < 0x7F ? 0x40 : 0x62;\n\n        // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +\n        // (byte − offset).\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE)) pointer = (lead - 0x81) * 157 + (bite - offset);\n\n        // 3. If there is a row in the table below whose first column\n        // is pointer, return the two code points listed in its second\n        // column\n        // Pointer | Code points\n        // --------+--------------\n        // 1133    | U+00CA U+0304\n        // 1135    | U+00CA U+030C\n        // 1164    | U+00EA U+0304\n        // 1166    | U+00EA U+030C\n        switch (pointer) {\n          case 1133:\n            return [0x00CA, 0x0304];\n          case 1135:\n            return [0x00CA, 0x030C];\n          case 1164:\n            return [0x00EA, 0x0304];\n          case 1166:\n            return [0x00EA, 0x030C];\n        }\n\n        // 4. Let code point be null if pointer is null and the index\n        // code point for pointer in index Big5 otherwise.\n        var code_point = pointer === null ? null : indexCodePointFor(pointer, index('big5'));\n\n        // 5. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n        // 6. If code point is null, return error.\n        if (code_point === null) return decoderError(fatal);\n\n        // 7. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite)) return bite;\n\n      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n      // lead to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        Big5_lead = bite;\n        return null;\n      }\n\n      // 6. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 12.1.2 Big5 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function Big5Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 3. Let pointer be the index Big5 pointer for code point.\n      var pointer = indexBig5PointerFor(code_point);\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null) return encoderError(code_point);\n\n      // 5. Let lead be floor(pointer / 157) + 0x81.\n      var lead = floor(pointer / 157) + 0x81;\n\n      // 6. If lead is less than 0xA1, return error with code point.\n      if (lead < 0xA1) return encoderError(code_point);\n\n      // 7. Let trail be pointer % 157.\n      var trail = pointer % 157;\n\n      // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n      // otherwise.\n      var offset = trail < 0x3F ? 0x40 : 0x62;\n\n      // Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['Big5'] = function (options) {\n    return new Big5Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['Big5'] = function (options) {\n    return new Big5Decoder(options);\n  };\n\n  //\n  // 13. Legacy multi-byte Japanese encodings\n  //\n\n  // 13.1 euc-jp\n\n  // 13.1.1 euc-jp decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCJPDecoder(options) {\n    var fatal = options.fatal;\n\n    // euc-jp's decoder has an associated euc-jp jis0212 flag\n    // (initially unset) and euc-jp lead (initially 0x00).\n    var /** @type {boolean} */eucjp_jis0212_flag = false,\n      /** @type {number} */eucjp_lead = 0x00;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n      // euc-jp lead to 0x00, and return error.\n      if (bite === end_of_stream && eucjp_lead !== 0x00) {\n        eucjp_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && eucjp_lead === 0x00) return finished;\n\n      // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n      // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n      // point whose value is 0xFF61 − 0xA1 + byte.\n      if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {\n        eucjp_lead = 0x00;\n        return 0xFF61 - 0xA1 + bite;\n      }\n\n      // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n      // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n      // to byte, and return continue.\n      if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {\n        eucjp_jis0212_flag = true;\n        eucjp_lead = bite;\n        return null;\n      }\n\n      // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n      // euc-jp lead to 0x00, and run these substeps:\n      if (eucjp_lead !== 0x00) {\n        var lead = eucjp_lead;\n        eucjp_lead = 0x00;\n\n        // 1. Let code point be null.\n        var code_point = null;\n\n        // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n        // inclusive, set code point to the index code point for (lead\n        // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp\n        // jis0212 flag is unset and in index jis0212 otherwise.\n        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n          code_point = indexCodePointFor((lead - 0xA1) * 94 + (bite - 0xA1), index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));\n        }\n\n        // 3. Unset the euc-jp jis0212 flag.\n        eucjp_jis0212_flag = false;\n\n        // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n        // prepend byte to stream.\n        if (!inRange(bite, 0xA1, 0xFE)) stream.prepend(bite);\n\n        // 5. If code point is null, return error.\n        if (code_point === null) return decoderError(fatal);\n\n        // 6. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite)) return bite;\n\n      // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n      // inclusive, set euc-jp lead to byte and return continue.\n      if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\n        eucjp_lead = bite;\n        return null;\n      }\n\n      // 8. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 13.1.2 euc-jp encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCJPEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 3. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5) return 0x5C;\n\n      // 4. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E) return 0x7E;\n\n      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return two bytes whose values are 0x8E and code point −\n      // 0xFF61 + 0xA1.\n      if (inRange(code_point, 0xFF61, 0xFF9F)) return [0x8E, code_point - 0xFF61 + 0xA1];\n\n      // 6. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212) code_point = 0xFF0D;\n\n      // 7. Let pointer be the index pointer for code point in index\n      // jis0208.\n      var pointer = indexPointerFor(code_point, index('jis0208'));\n\n      // 8. If pointer is null, return error with code point.\n      if (pointer === null) return encoderError(code_point);\n\n      // 9. Let lead be floor(pointer / 94) + 0xA1.\n      var lead = floor(pointer / 94) + 0xA1;\n\n      // 10. Let trail be pointer % 94 + 0xA1.\n      var trail = pointer % 94 + 0xA1;\n\n      // 11. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['EUC-JP'] = function (options) {\n    return new EUCJPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['EUC-JP'] = function (options) {\n    return new EUCJPDecoder(options);\n  };\n\n  // 13.2 iso-2022-jp\n\n  // 13.2.1 iso-2022-jp decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ISO2022JPDecoder(options) {\n    var fatal = options.fatal;\n    /** @enum */\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      Katakana: 2,\n      LeadByte: 3,\n      TrailByte: 4,\n      EscapeStart: 5,\n      Escape: 6\n    };\n    // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n    // state (initially ASCII), iso-2022-jp decoder output state\n    // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n    // iso-2022-jp output flag (initially unset).\n    var /** @type {number} */iso2022jp_decoder_state = states.ASCII,\n      /** @type {number} */iso2022jp_decoder_output_state = states.ASCII,\n      /** @type {number} */iso2022jp_lead = 0x00,\n      /** @type {boolean} */iso2022jp_output_flag = false;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function (stream, bite) {\n      // switching on iso-2022-jp decoder state:\n      switch (iso2022jp_decoder_state) {\n        default:\n        case states.ASCII:\n          // ASCII\n          // Based on byte:\n\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return null;\n          }\n\n          // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n          if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F && bite !== 0x1B) {\n            // Unset the iso-2022-jp output flag and return a code point\n            // whose value is byte.\n            iso2022jp_output_flag = false;\n            return bite;\n          }\n\n          // end-of-stream\n          if (bite === end_of_stream) {\n            // Return finished.\n            return finished;\n          }\n\n          // Otherwise\n          // Unset the iso-2022-jp output flag and return error.\n          iso2022jp_output_flag = false;\n          return decoderError(fatal);\n        case states.Roman:\n          // Roman\n          // Based on byte:\n\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return null;\n          }\n\n          // 0x5C\n          if (bite === 0x5C) {\n            // Unset the iso-2022-jp output flag and return code point\n            // U+00A5.\n            iso2022jp_output_flag = false;\n            return 0x00A5;\n          }\n\n          // 0x7E\n          if (bite === 0x7E) {\n            // Unset the iso-2022-jp output flag and return code point\n            // U+203E.\n            iso2022jp_output_flag = false;\n            return 0x203E;\n          }\n\n          // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n          if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {\n            // Unset the iso-2022-jp output flag and return a code point\n            // whose value is byte.\n            iso2022jp_output_flag = false;\n            return bite;\n          }\n\n          // end-of-stream\n          if (bite === end_of_stream) {\n            // Return finished.\n            return finished;\n          }\n\n          // Otherwise\n          // Unset the iso-2022-jp output flag and return error.\n          iso2022jp_output_flag = false;\n          return decoderError(fatal);\n        case states.Katakana:\n          // Katakana\n          // Based on byte:\n\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return null;\n          }\n\n          // 0x21 to 0x5F\n          if (inRange(bite, 0x21, 0x5F)) {\n            // Unset the iso-2022-jp output flag and return a code point\n            // whose value is 0xFF61 − 0x21 + byte.\n            iso2022jp_output_flag = false;\n            return 0xFF61 - 0x21 + bite;\n          }\n\n          // end-of-stream\n          if (bite === end_of_stream) {\n            // Return finished.\n            return finished;\n          }\n\n          // Otherwise\n          // Unset the iso-2022-jp output flag and return error.\n          iso2022jp_output_flag = false;\n          return decoderError(fatal);\n        case states.LeadByte:\n          // Lead byte\n          // Based on byte:\n\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return null;\n          }\n\n          // 0x21 to 0x7E\n          if (inRange(bite, 0x21, 0x7E)) {\n            // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n            // to byte, iso-2022-jp decoder state to trail byte, and\n            // return continue.\n            iso2022jp_output_flag = false;\n            iso2022jp_lead = bite;\n            iso2022jp_decoder_state = states.TrailByte;\n            return null;\n          }\n\n          // end-of-stream\n          if (bite === end_of_stream) {\n            // Return finished.\n            return finished;\n          }\n\n          // Otherwise\n          // Unset the iso-2022-jp output flag and return error.\n          iso2022jp_output_flag = false;\n          return decoderError(fatal);\n        case states.TrailByte:\n          // Trail byte\n          // Based on byte:\n\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return decoderError(fatal);\n          }\n\n          // 0x21 to 0x7E\n          if (inRange(bite, 0x21, 0x7E)) {\n            // 1. Set the iso-2022-jp decoder state to lead byte.\n            iso2022jp_decoder_state = states.LeadByte;\n\n            // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\n            var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;\n\n            // 3. Let code point be the index code point for pointer in\n            // index jis0208.\n            var code_point = indexCodePointFor(pointer, index('jis0208'));\n\n            // 4. If code point is null, return error.\n            if (code_point === null) return decoderError(fatal);\n\n            // 5. Return a code point whose value is code point.\n            return code_point;\n          }\n\n          // end-of-stream\n          if (bite === end_of_stream) {\n            // Set the iso-2022-jp decoder state to lead byte, prepend\n            // byte to stream, and return error.\n            iso2022jp_decoder_state = states.LeadByte;\n            stream.prepend(bite);\n            return decoderError(fatal);\n          }\n\n          // Otherwise\n          // Set iso-2022-jp decoder state to lead byte and return\n          // error.\n          iso2022jp_decoder_state = states.LeadByte;\n          return decoderError(fatal);\n        case states.EscapeStart:\n          // Escape start\n\n          // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n          // byte, iso-2022-jp decoder state to escape, and return\n          // continue.\n          if (bite === 0x24 || bite === 0x28) {\n            iso2022jp_lead = bite;\n            iso2022jp_decoder_state = states.Escape;\n            return null;\n          }\n\n          // 2. Prepend byte to stream.\n          stream.prepend(bite);\n\n          // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n          // decoder state to iso-2022-jp decoder output state, and\n          // return error.\n          iso2022jp_output_flag = false;\n          iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n          return decoderError(fatal);\n        case states.Escape:\n          // Escape\n\n          // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n          // 0x00.\n          var lead = iso2022jp_lead;\n          iso2022jp_lead = 0x00;\n\n          // 2. Let state be null.\n          var state = null;\n\n          // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n          if (lead === 0x28 && bite === 0x42) state = states.ASCII;\n\n          // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n          if (lead === 0x28 && bite === 0x4A) state = states.Roman;\n\n          // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n          if (lead === 0x28 && bite === 0x49) state = states.Katakana;\n\n          // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n          // state to lead byte.\n          if (lead === 0x24 && (bite === 0x40 || bite === 0x42)) state = states.LeadByte;\n\n          // 7. If state is non-null, run these substeps:\n          if (state !== null) {\n            // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n            // output state to states.\n            iso2022jp_decoder_state = iso2022jp_decoder_state = state;\n\n            // 2. Let output flag be the iso-2022-jp output flag.\n            var output_flag = iso2022jp_output_flag;\n\n            // 3. Set the iso-2022-jp output flag.\n            iso2022jp_output_flag = true;\n\n            // 4. Return continue, if output flag is unset, and error\n            // otherwise.\n            return !output_flag ? null : decoderError(fatal);\n          }\n\n          // 8. Prepend lead and byte to stream.\n          stream.prepend([lead, bite]);\n\n          // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n          // decoder state to iso-2022-jp decoder output state and\n          // return error.\n          iso2022jp_output_flag = false;\n          iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n          return decoderError(fatal);\n      }\n    };\n  }\n\n  // 13.2.2 iso-2022-jp encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ISO2022JPEncoder(options) {\n    var fatal = options.fatal;\n    // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n    // state which is one of ASCII, Roman, and jis0208 (initially\n    // ASCII).\n    /** @enum */\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      jis0208: 2\n    };\n    var /** @type {number} */iso2022jp_state = states.ASCII;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream and iso-2022-jp encoder\n      // state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n\n      // 2. If code point is end-of-stream and iso-2022-jp encoder\n      // state is ASCII, return finished.\n      if (code_point === end_of_stream && iso2022jp_state === states.ASCII) return finished;\n\n      // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n      // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n      if ((iso2022jp_state === states.ASCII || iso2022jp_state === states.Roman) && (code_point === 0x000E || code_point === 0x000F || code_point === 0x001B)) {\n        return encoderError(0xFFFD);\n      }\n\n      // 4. If iso-2022-jp encoder state is ASCII and code point is an\n      // ASCII code point, return a byte whose value is code point.\n      if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point)) return code_point;\n\n      // 5. If iso-2022-jp encoder state is Roman and code point is an\n      // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n      // or U+203E, run these substeps:\n      if (iso2022jp_state === states.Roman && (isASCIICodePoint(code_point) && code_point !== 0x005C && code_point !== 0x007E || code_point == 0x00A5 || code_point == 0x203E)) {\n        // 1. If code point is an ASCII code point, return a byte\n        // whose value is code point.\n        if (isASCIICodePoint(code_point)) return code_point;\n\n        // 2. If code point is U+00A5, return byte 0x5C.\n        if (code_point === 0x00A5) return 0x5C;\n\n        // 3. If code point is U+203E, return byte 0x7E.\n        if (code_point === 0x203E) return 0x7E;\n      }\n\n      // 6. If code point is an ASCII code point, and iso-2022-jp\n      // encoder state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n\n      // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n      // encoder state is not Roman, prepend code point to stream, set\n      // iso-2022-jp encoder state to Roman, and return three bytes\n      // 0x1B 0x28 0x4A.\n      if ((code_point === 0x00A5 || code_point === 0x203E) && iso2022jp_state !== states.Roman) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.Roman;\n        return [0x1B, 0x28, 0x4A];\n      }\n\n      // 8. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212) code_point = 0xFF0D;\n\n      // 9. Let pointer be the index pointer for code point in index\n      // jis0208.\n      var pointer = indexPointerFor(code_point, index('jis0208'));\n\n      // 10. If pointer is null, return error with code point.\n      if (pointer === null) return encoderError(code_point);\n\n      // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n      // point to stream, set iso-2022-jp encoder state to jis0208,\n      // and return three bytes 0x1B 0x24 0x42.\n      if (iso2022jp_state !== states.jis0208) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.jis0208;\n        return [0x1B, 0x24, 0x42];\n      }\n\n      // 12. Let lead be floor(pointer / 94) + 0x21.\n      var lead = floor(pointer / 94) + 0x21;\n\n      // 13. Let trail be pointer % 94 + 0x21.\n      var trail = pointer % 94 + 0x21;\n\n      // 14. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['ISO-2022-JP'] = function (options) {\n    return new ISO2022JPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['ISO-2022-JP'] = function (options) {\n    return new ISO2022JPDecoder(options);\n  };\n\n  // 13.3 Shift_JIS\n\n  // 13.3.1 Shift_JIS decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ShiftJISDecoder(options) {\n    var fatal = options.fatal;\n    // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n    // 0x00).\n    var /** @type {number} */Shift_JIS_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n      // set Shift_JIS lead to 0x00 and return error.\n      if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {\n        Shift_JIS_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n      // return finished.\n      if (bite === end_of_stream && Shift_JIS_lead === 0x00) return finished;\n\n      // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n      // let pointer be null, set Shift_JIS lead to 0x00, and then run\n      // these substeps:\n      if (Shift_JIS_lead !== 0x00) {\n        var lead = Shift_JIS_lead;\n        var pointer = null;\n        Shift_JIS_lead = 0x00;\n\n        // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n        // otherwise.\n        var offset = bite < 0x7F ? 0x40 : 0x41;\n\n        // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n        // 0xC1 otherwise.\n        var lead_offset = lead < 0xA0 ? 0x81 : 0xC1;\n\n        // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFC, inclusive, set pointer to (lead − lead offset) ×\n        // 188 + byte − offset.\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC)) pointer = (lead - lead_offset) * 188 + bite - offset;\n\n        // 4. If pointer is in the range 8836 to 10715, inclusive,\n        // return a code point whose value is 0xE000 − 8836 + pointer.\n        if (inRange(pointer, 8836, 10715)) return 0xE000 - 8836 + pointer;\n\n        // 5. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index jis0208 otherwise.\n        var code_point = pointer === null ? null : indexCodePointFor(pointer, index('jis0208'));\n\n        // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n        // 7. If code point is null, return error.\n        if (code_point === null) return decoderError(fatal);\n\n        // 8. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte or 0x80, return a code point\n      // whose value is byte.\n      if (isASCIIByte(bite) || bite === 0x80) return bite;\n\n      // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n      // code point whose value is 0xFF61 − 0xA1 + byte.\n      if (inRange(bite, 0xA1, 0xDF)) return 0xFF61 - 0xA1 + bite;\n\n      // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n      // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n      // continue.\n      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\n        Shift_JIS_lead = bite;\n        return null;\n      }\n\n      // 7. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 13.3.2 Shift_JIS encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ShiftJISEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished;\n\n      // 2. If code point is an ASCII code point or U+0080, return a\n      // byte whose value is code point.\n      if (isASCIICodePoint(code_point) || code_point === 0x0080) return code_point;\n\n      // 3. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5) return 0x5C;\n\n      // 4. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E) return 0x7E;\n\n      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return a byte whose value is code point − 0xFF61 + 0xA1.\n      if (inRange(code_point, 0xFF61, 0xFF9F)) return code_point - 0xFF61 + 0xA1;\n\n      // 6. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212) code_point = 0xFF0D;\n\n      // 7. Let pointer be the index Shift_JIS pointer for code point.\n      var pointer = indexShiftJISPointerFor(code_point);\n\n      // 8. If pointer is null, return error with code point.\n      if (pointer === null) return encoderError(code_point);\n\n      // 9. Let lead be floor(pointer / 188).\n      var lead = floor(pointer / 188);\n\n      // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n      // 0xC1 otherwise.\n      var lead_offset = lead < 0x1F ? 0x81 : 0xC1;\n\n      // 11. Let trail be pointer % 188.\n      var trail = pointer % 188;\n\n      // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n      // otherwise.\n      var offset = trail < 0x3F ? 0x40 : 0x41;\n\n      // 13. Return two bytes whose values are lead + lead offset and\n      // trail + offset.\n      return [lead + lead_offset, trail + offset];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['Shift_JIS'] = function (options) {\n    return new ShiftJISEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['Shift_JIS'] = function (options) {\n    return new ShiftJISDecoder(options);\n  };\n\n  //\n  // 14. Legacy multi-byte Korean encodings\n  //\n\n  // 14.1 euc-kr\n\n  // 14.1.1 euc-kr decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCKRDecoder(options) {\n    var fatal = options.fatal;\n\n    // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n    var /** @type {number} */euckr_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n      // euc-kr lead to 0x00 and return error.\n      if (bite === end_of_stream && euckr_lead !== 0) {\n        euckr_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && euckr_lead === 0) return finished;\n\n      // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n      // pointer be null, set euc-kr lead to 0x00, and then run these\n      // substeps:\n      if (euckr_lead !== 0x00) {\n        var lead = euckr_lead;\n        var pointer = null;\n        euckr_lead = 0x00;\n\n        // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n        // pointer to (lead − 0x81) × 190 + (byte − 0x41).\n        if (inRange(bite, 0x41, 0xFE)) pointer = (lead - 0x81) * 190 + (bite - 0x41);\n\n        // 2. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index euc-kr otherwise.\n        var code_point = pointer === null ? null : indexCodePointFor(pointer, index('euc-kr'));\n\n        // 3. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (pointer === null && isASCIIByte(bite)) stream.prepend(bite);\n\n        // 4. If code point is null, return error.\n        if (code_point === null) return decoderError(fatal);\n\n        // 5. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite)) return bite;\n\n      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // euc-kr lead to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        euckr_lead = bite;\n        return null;\n      }\n\n      // 6. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 14.1.2 euc-kr encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCKREncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 3. Let pointer be the index pointer for code point in index\n      // euc-kr.\n      var pointer = indexPointerFor(code_point, index('euc-kr'));\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null) return encoderError(code_point);\n\n      // 5. Let lead be floor(pointer / 190) + 0x81.\n      var lead = floor(pointer / 190) + 0x81;\n\n      // 6. Let trail be pointer % 190 + 0x41.\n      var trail = pointer % 190 + 0x41;\n\n      // 7. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['EUC-KR'] = function (options) {\n    return new EUCKREncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['EUC-KR'] = function (options) {\n    return new EUCKRDecoder(options);\n  };\n\n  //\n  // 15. Legacy miscellaneous encodings\n  //\n\n  // 15.1 replacement\n\n  // Not needed - API throws RangeError\n\n  // 15.2 Common infrastructure for utf-16be and utf-16le\n\n  /**\n   * @param {number} code_unit\n   * @param {boolean} utf16be\n   * @return {!Array.<number>} bytes\n   */\n  function convertCodeUnitToBytes(code_unit, utf16be) {\n    // 1. Let byte1 be code unit >> 8.\n    var byte1 = code_unit >> 8;\n\n    // 2. Let byte2 be code unit & 0x00FF.\n    var byte2 = code_unit & 0x00FF;\n\n    // 3. Then return the bytes in order:\n    // utf-16be flag is set: byte1, then byte2.\n    if (utf16be) return [byte1, byte2];\n    // utf-16be flag is unset: byte2, then byte1.\n    return [byte2, byte1];\n  }\n\n  // 15.2.1 shared utf-16 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n  function UTF16Decoder(utf16_be, options) {\n    var fatal = options.fatal;\n    var /** @type {?number} */utf16_lead_byte = null,\n      /** @type {?number} */utf16_lead_surrogate = null;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and either utf-16 lead byte or\n      // utf-16 lead surrogate is not null, set utf-16 lead byte and\n      // utf-16 lead surrogate to null, and return error.\n      if (bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\n      // lead surrogate are null, return finished.\n      if (bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {\n        return finished;\n      }\n\n      // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\n      // and return continue.\n      if (utf16_lead_byte === null) {\n        utf16_lead_byte = bite;\n        return null;\n      }\n\n      // 4. Let code unit be the result of:\n      var code_unit;\n      if (utf16_be) {\n        // utf-16be decoder flag is set\n        //   (utf-16 lead byte << 8) + byte.\n        code_unit = (utf16_lead_byte << 8) + bite;\n      } else {\n        // utf-16be decoder flag is unset\n        //   (byte << 8) + utf-16 lead byte.\n        code_unit = (bite << 8) + utf16_lead_byte;\n      }\n      // Then set utf-16 lead byte to null.\n      utf16_lead_byte = null;\n\n      // 5. If utf-16 lead surrogate is not null, let lead surrogate\n      // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\n      // and then run these substeps:\n      if (utf16_lead_surrogate !== null) {\n        var lead_surrogate = utf16_lead_surrogate;\n        utf16_lead_surrogate = null;\n\n        // 1. If code unit is in the range U+DC00 to U+DFFF,\n        // inclusive, return a code point whose value is 0x10000 +\n        // ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).\n        if (inRange(code_unit, 0xDC00, 0xDFFF)) {\n          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 + (code_unit - 0xDC00);\n        }\n\n        // 2. Prepend the sequence resulting of converting code unit\n        // to bytes using utf-16be decoder flag to stream and return\n        // error.\n        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\n        return decoderError(fatal);\n      }\n\n      // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,\n      // set utf-16 lead surrogate to code unit and return continue.\n      if (inRange(code_unit, 0xD800, 0xDBFF)) {\n        utf16_lead_surrogate = code_unit;\n        return null;\n      }\n\n      // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,\n      // return error.\n      if (inRange(code_unit, 0xDC00, 0xDFFF)) return decoderError(fatal);\n\n      // 8. Return code point code unit.\n      return code_unit;\n    };\n  }\n\n  // 15.2.2 shared utf-16 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n  function UTF16Encoder(utf16_be, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished;\n\n      // 2. If code point is in the range U+0000 to U+FFFF, inclusive,\n      // return the sequence resulting of converting code point to\n      // bytes using utf-16be encoder flag.\n      if (inRange(code_point, 0x0000, 0xFFFF)) return convertCodeUnitToBytes(code_point, utf16_be);\n\n      // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,\n      // converted to bytes using utf-16be encoder flag.\n      var lead = convertCodeUnitToBytes((code_point - 0x10000 >> 10) + 0xD800, utf16_be);\n\n      // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,\n      // converted to bytes using utf-16be encoder flag.\n      var trail = convertCodeUnitToBytes((code_point - 0x10000 & 0x3FF) + 0xDC00, utf16_be);\n\n      // 5. Return a byte sequence of lead followed by trail.\n      return lead.concat(trail);\n    };\n  }\n\n  // 15.3 utf-16be\n  // 15.3.1 utf-16be decoder\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-16BE'] = function (options) {\n    return new UTF16Encoder(true, options);\n  };\n  // 15.3.2 utf-16be encoder\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-16BE'] = function (options) {\n    return new UTF16Decoder(true, options);\n  };\n\n  // 15.4 utf-16le\n  // 15.4.1 utf-16le decoder\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-16LE'] = function (options) {\n    return new UTF16Encoder(false, options);\n  };\n  // 15.4.2 utf-16le encoder\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-16LE'] = function (options) {\n    return new UTF16Decoder(false, options);\n  };\n\n  // 15.5 x-user-defined\n\n  // 15.5.1 x-user-defined decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function XUserDefinedDecoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream) return finished;\n\n      // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite)) return bite;\n\n      // 3. Return a code point whose value is 0xF780 + byte − 0x80.\n      return 0xF780 + bite - 0x80;\n    };\n  }\n\n  // 15.5.2 x-user-defined encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function XUserDefinedEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function (stream, code_point) {\n      // 1.If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 3. If code point is in the range U+F780 to U+F7FF, inclusive,\n      // return a byte whose value is code point − 0xF780 + 0x80.\n      if (inRange(code_point, 0xF780, 0xF7FF)) return code_point - 0xF780 + 0x80;\n\n      // 4. Return error with code point.\n      return encoderError(code_point);\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['x-user-defined'] = function (options) {\n    return new XUserDefinedEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['x-user-defined'] = function (options) {\n    return new XUserDefinedDecoder(options);\n  };\n  if (!global['TextEncoder']) global['TextEncoder'] = TextEncoder;\n  if (!global['TextDecoder']) global['TextDecoder'] = TextDecoder;\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = {\n      TextEncoder: global['TextEncoder'],\n      TextDecoder: global['TextDecoder'],\n      EncodingIndexes: global[\"encoding-indexes\"]\n    };\n  }\n\n  // For strict environments where `this` inside the global scope\n  // is `undefined`, take a pure object instead\n})(this || {});","map":{"version":3,"names":["global","module","exports","require","inRange","a","min","max","includes","array","item","indexOf","floor","Math","ToDictionary","o","undefined","Object","TypeError","stringToCodePoints","string","s","String","n","length","i","u","c","charCodeAt","push","d","b","codePointsToString","code_points","cp","fromCharCode","isASCIIByte","isASCIICodePoint","end_of_stream","Stream","tokens","slice","call","reverse","prototype","endOfStream","read","pop","prepend","token","Array","isArray","unshift","shift","finished","decoderError","fatal","opt_code_point","encoderError","code_point","Decoder","handler","stream","bite","Encoder","getEncoding","label","trim","toLowerCase","hasOwnProperty","label_to_encoding","encodings","forEach","category","encoding","labels","encoders","decoders","indexCodePointFor","pointer","index","indexPointerFor","name","Error","indexGB18030RangesCodePointFor","offset","code_point_offset","idx","entry","indexGB18030RangesPointerFor","pointer_offset","indexShiftJISPointerFor","shift_jis_index","map","index_","indexBig5PointerFor","big5_index_no_hkscs","lastIndexOf","DEFAULT_ENCODING","TextDecoder","options","_encoding","_decoder","_ignoreBOM","_BOMseen","_error_mode","_do_not_flush","RangeError","dec","Boolean","defineProperty","ignoreBOM","get","decode","input","bytes","ArrayBuffer","Uint8Array","buffer","byteOffset","byteLength","input_stream","output","result","apply","serializeStream","TextEncoder","_encoder","_fatal","enc","console","warn","encode","opt_string","UTF8Decoder","utf8_code_point","utf8_bytes_seen","utf8_bytes_needed","utf8_lower_boundary","utf8_upper_boundary","UTF8Encoder","count","temp","SingleByteDecoder","SingleByteEncoder","heading","GB18030Decoder","GB18030Encoder","gb18030_first","gb18030_second","gb18030_third","lead","gbk_flag","trail","byte1","byte2","byte3","byte4","Big5Decoder","Big5_lead","Big5Encoder","EUCJPDecoder","eucjp_jis0212_flag","eucjp_lead","EUCJPEncoder","ISO2022JPDecoder","states","ASCII","Roman","Katakana","LeadByte","TrailByte","EscapeStart","Escape","iso2022jp_decoder_state","iso2022jp_decoder_output_state","iso2022jp_lead","iso2022jp_output_flag","state","output_flag","ISO2022JPEncoder","jis0208","iso2022jp_state","ShiftJISDecoder","Shift_JIS_lead","lead_offset","ShiftJISEncoder","EUCKRDecoder","euckr_lead","EUCKREncoder","convertCodeUnitToBytes","code_unit","utf16be","UTF16Decoder","utf16_be","utf16_lead_byte","utf16_lead_surrogate","lead_surrogate","UTF16Encoder","concat","XUserDefinedDecoder","XUserDefinedEncoder","EncodingIndexes"],"sources":["/home/vaslyb/Desktop/witheflow/annotator/src/node_modules/text-encoding/lib/encoding.js"],"sourcesContent":["// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n/**\n * @fileoverview Global |this| required for resolving indexes in node.\n * @suppress {globalThis}\n */\n(function(global) {\n  'use strict';\n\n  // If we're in node require encoding-indexes and attach it to the global.\n  if (typeof module !== \"undefined\" && module.exports &&\n    !global[\"encoding-indexes\"]) {\n    global[\"encoding-indexes\"] =\n      require(\"./encoding-indexes.js\")[\"encoding-indexes\"];\n  }\n\n  //\n  // Utilities\n  //\n\n  /**\n   * @param {number} a The number to test.\n   * @param {number} min The minimum value in the range, inclusive.\n   * @param {number} max The maximum value in the range, inclusive.\n   * @return {boolean} True if a >= min and a <= max.\n   */\n  function inRange(a, min, max) {\n    return min <= a && a <= max;\n  }\n\n  /**\n   * @param {!Array.<*>} array The array to check.\n   * @param {*} item The item to look for in the array.\n   * @return {boolean} True if the item appears in the array.\n   */\n  function includes(array, item) {\n    return array.indexOf(item) !== -1;\n  }\n\n  var floor = Math.floor;\n\n  /**\n   * @param {*} o\n   * @return {Object}\n   */\n  function ToDictionary(o) {\n    if (o === undefined) return {};\n    if (o === Object(o)) return o;\n    throw TypeError('Could not convert argument to dictionary');\n  }\n\n  /**\n   * @param {string} string Input string of UTF-16 code units.\n   * @return {!Array.<number>} Code points.\n   */\n  function stringToCodePoints(string) {\n    // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n    // 1. Let S be the DOMString value.\n    var s = String(string);\n\n    // 2. Let n be the length of S.\n    var n = s.length;\n\n    // 3. Initialize i to 0.\n    var i = 0;\n\n    // 4. Initialize U to be an empty sequence of Unicode characters.\n    var u = [];\n\n    // 5. While i < n:\n    while (i < n) {\n\n      // 1. Let c be the code unit in S at index i.\n      var c = s.charCodeAt(i);\n\n      // 2. Depending on the value of c:\n\n      // c < 0xD800 or c > 0xDFFF\n      if (c < 0xD800 || c > 0xDFFF) {\n        // Append to U the Unicode character with code point c.\n        u.push(c);\n      }\n\n      // 0xDC00 ≤ c ≤ 0xDFFF\n      else if (0xDC00 <= c && c <= 0xDFFF) {\n        // Append to U a U+FFFD REPLACEMENT CHARACTER.\n        u.push(0xFFFD);\n      }\n\n      // 0xD800 ≤ c ≤ 0xDBFF\n      else if (0xD800 <= c && c <= 0xDBFF) {\n        // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n        // CHARACTER.\n        if (i === n - 1) {\n          u.push(0xFFFD);\n        }\n        // 2. Otherwise, i < n−1:\n        else {\n          // 1. Let d be the code unit in S at index i+1.\n          var d = s.charCodeAt(i + 1);\n\n          // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n          if (0xDC00 <= d && d <= 0xDFFF) {\n            // 1. Let a be c & 0x3FF.\n            var a = c & 0x3FF;\n\n            // 2. Let b be d & 0x3FF.\n            var b = d & 0x3FF;\n\n            // 3. Append to U the Unicode character with code point\n            // 2^16+2^10*a+b.\n            u.push(0x10000 + (a << 10) + b);\n\n            // 4. Set i to i+1.\n            i += 1;\n          }\n\n          // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n          // U+FFFD REPLACEMENT CHARACTER.\n          else  {\n            u.push(0xFFFD);\n          }\n        }\n      }\n\n      // 3. Set i to i+1.\n      i += 1;\n    }\n\n    // 6. Return U.\n    return u;\n  }\n\n  /**\n   * @param {!Array.<number>} code_points Array of code points.\n   * @return {string} string String of UTF-16 code units.\n   */\n  function codePointsToString(code_points) {\n    var s = '';\n    for (var i = 0; i < code_points.length; ++i) {\n      var cp = code_points[i];\n      if (cp <= 0xFFFF) {\n        s += String.fromCharCode(cp);\n      } else {\n        cp -= 0x10000;\n        s += String.fromCharCode((cp >> 10) + 0xD800,\n                                 (cp & 0x3FF) + 0xDC00);\n      }\n    }\n    return s;\n  }\n\n\n  //\n  // Implementation of Encoding specification\n  // https://encoding.spec.whatwg.org/\n  //\n\n  //\n  // 4. Terminology\n  //\n\n  /**\n   * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n   * @param {number} a The number to test.\n   * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n   */\n  function isASCIIByte(a) {\n    return 0x00 <= a && a <= 0x7F;\n  }\n\n  /**\n   * An ASCII code point is a code point in the range U+0000 to\n   * U+007F, inclusive.\n   */\n  var isASCIICodePoint = isASCIIByte;\n\n\n  /**\n   * End-of-stream is a special token that signifies no more tokens\n   * are in the stream.\n   * @const\n   */ var end_of_stream = -1;\n\n  /**\n   * A stream represents an ordered sequence of tokens.\n   *\n   * @constructor\n   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n   * the stream.\n   */\n  function Stream(tokens) {\n    /** @type {!Array.<number>} */\n    this.tokens = [].slice.call(tokens);\n    // Reversed as push/pop is more efficient than shift/unshift.\n    this.tokens.reverse();\n  }\n\n  Stream.prototype = {\n    /**\n     * @return {boolean} True if end-of-stream has been hit.\n     */\n    endOfStream: function() {\n      return !this.tokens.length;\n    },\n\n    /**\n     * When a token is read from a stream, the first token in the\n     * stream must be returned and subsequently removed, and\n     * end-of-stream must be returned otherwise.\n     *\n     * @return {number} Get the next token from the stream, or\n     * end_of_stream.\n     */\n     read: function() {\n      if (!this.tokens.length)\n        return end_of_stream;\n       return this.tokens.pop();\n     },\n\n    /**\n     * When one or more tokens are prepended to a stream, those tokens\n     * must be inserted, in given order, before the first token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n     * stream.\n     */\n    prepend: function(token) {\n      if (Array.isArray(token)) {\n        var tokens = /**@type {!Array.<number>}*/(token);\n        while (tokens.length)\n          this.tokens.push(tokens.pop());\n      } else {\n        this.tokens.push(token);\n      }\n    },\n\n    /**\n     * When one or more tokens are pushed to a stream, those tokens\n     * must be inserted, in given order, after the last token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n     * stream.\n     */\n    push: function(token) {\n      if (Array.isArray(token)) {\n        var tokens = /**@type {!Array.<number>}*/(token);\n        while (tokens.length)\n          this.tokens.unshift(tokens.shift());\n      } else {\n        this.tokens.unshift(token);\n      }\n    }\n  };\n\n  //\n  // 5. Encodings\n  //\n\n  // 5.1 Encoders and decoders\n\n  /** @const */\n  var finished = -1;\n\n  /**\n   * @param {boolean} fatal If true, decoding errors raise an exception.\n   * @param {number=} opt_code_point Override the standard fallback code point.\n   * @return {number} The code point to insert on a decoding error.\n   */\n  function decoderError(fatal, opt_code_point) {\n    if (fatal)\n      throw TypeError('Decoder error');\n    return opt_code_point || 0xFFFD;\n  }\n\n  /**\n   * @param {number} code_point The code point that could not be encoded.\n   * @return {number} Always throws, no value is actually returned.\n   */\n  function encoderError(code_point) {\n    throw TypeError('The code point ' + code_point + ' could not be encoded.');\n  }\n\n  /** @interface */\n  function Decoder() {}\n  Decoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point, or |finished|.\n     */\n    handler: function(stream, bite) {}\n  };\n\n  /** @interface */\n  function Encoder() {}\n  Encoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of code points being encoded.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n     */\n    handler: function(stream, code_point) {}\n  };\n\n  // 5.2 Names and labels\n\n  // TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\n  // https://github.com/google/closure-compiler/issues/247\n\n  /**\n   * @param {string} label The encoding label.\n   * @return {?{name:string,labels:Array.<string>}}\n   */\n  function getEncoding(label) {\n    // 1. Remove any leading and trailing ASCII whitespace from label.\n    label = String(label).trim().toLowerCase();\n\n    // 2. If label is an ASCII case-insensitive match for any of the\n    // labels listed in the table below, return the corresponding\n    // encoding, and failure otherwise.\n    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n      return label_to_encoding[label];\n    }\n    return null;\n  }\n\n  /**\n   * Encodings table: https://encoding.spec.whatwg.org/encodings.json\n   * @const\n   * @type {!Array.<{\n   *          heading: string,\n   *          encodings: Array.<{name:string,labels:Array.<string>}>\n   *        }>}\n   */\n  var encodings = [\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"unicode-1-1-utf-8\",\n            \"utf-8\",\n            \"utf8\"\n          ],\n          \"name\": \"UTF-8\"\n        }\n      ],\n      \"heading\": \"The Encoding\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"866\",\n            \"cp866\",\n            \"csibm866\",\n            \"ibm866\"\n          ],\n          \"name\": \"IBM866\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin2\",\n            \"iso-8859-2\",\n            \"iso-ir-101\",\n            \"iso8859-2\",\n            \"iso88592\",\n            \"iso_8859-2\",\n            \"iso_8859-2:1987\",\n            \"l2\",\n            \"latin2\"\n          ],\n          \"name\": \"ISO-8859-2\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin3\",\n            \"iso-8859-3\",\n            \"iso-ir-109\",\n            \"iso8859-3\",\n            \"iso88593\",\n            \"iso_8859-3\",\n            \"iso_8859-3:1988\",\n            \"l3\",\n            \"latin3\"\n          ],\n          \"name\": \"ISO-8859-3\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin4\",\n            \"iso-8859-4\",\n            \"iso-ir-110\",\n            \"iso8859-4\",\n            \"iso88594\",\n            \"iso_8859-4\",\n            \"iso_8859-4:1988\",\n            \"l4\",\n            \"latin4\"\n          ],\n          \"name\": \"ISO-8859-4\"\n        },\n        {\n          \"labels\": [\n            \"csisolatincyrillic\",\n            \"cyrillic\",\n            \"iso-8859-5\",\n            \"iso-ir-144\",\n            \"iso8859-5\",\n            \"iso88595\",\n            \"iso_8859-5\",\n            \"iso_8859-5:1988\"\n          ],\n          \"name\": \"ISO-8859-5\"\n        },\n        {\n          \"labels\": [\n            \"arabic\",\n            \"asmo-708\",\n            \"csiso88596e\",\n            \"csiso88596i\",\n            \"csisolatinarabic\",\n            \"ecma-114\",\n            \"iso-8859-6\",\n            \"iso-8859-6-e\",\n            \"iso-8859-6-i\",\n            \"iso-ir-127\",\n            \"iso8859-6\",\n            \"iso88596\",\n            \"iso_8859-6\",\n            \"iso_8859-6:1987\"\n          ],\n          \"name\": \"ISO-8859-6\"\n        },\n        {\n          \"labels\": [\n            \"csisolatingreek\",\n            \"ecma-118\",\n            \"elot_928\",\n            \"greek\",\n            \"greek8\",\n            \"iso-8859-7\",\n            \"iso-ir-126\",\n            \"iso8859-7\",\n            \"iso88597\",\n            \"iso_8859-7\",\n            \"iso_8859-7:1987\",\n            \"sun_eu_greek\"\n          ],\n          \"name\": \"ISO-8859-7\"\n        },\n        {\n          \"labels\": [\n            \"csiso88598e\",\n            \"csisolatinhebrew\",\n            \"hebrew\",\n            \"iso-8859-8\",\n            \"iso-8859-8-e\",\n            \"iso-ir-138\",\n            \"iso8859-8\",\n            \"iso88598\",\n            \"iso_8859-8\",\n            \"iso_8859-8:1988\",\n            \"visual\"\n          ],\n          \"name\": \"ISO-8859-8\"\n        },\n        {\n          \"labels\": [\n            \"csiso88598i\",\n            \"iso-8859-8-i\",\n            \"logical\"\n          ],\n          \"name\": \"ISO-8859-8-I\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin6\",\n            \"iso-8859-10\",\n            \"iso-ir-157\",\n            \"iso8859-10\",\n            \"iso885910\",\n            \"l6\",\n            \"latin6\"\n          ],\n          \"name\": \"ISO-8859-10\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-13\",\n            \"iso8859-13\",\n            \"iso885913\"\n          ],\n          \"name\": \"ISO-8859-13\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-14\",\n            \"iso8859-14\",\n            \"iso885914\"\n          ],\n          \"name\": \"ISO-8859-14\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin9\",\n            \"iso-8859-15\",\n            \"iso8859-15\",\n            \"iso885915\",\n            \"iso_8859-15\",\n            \"l9\"\n          ],\n          \"name\": \"ISO-8859-15\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-16\"\n          ],\n          \"name\": \"ISO-8859-16\"\n        },\n        {\n          \"labels\": [\n            \"cskoi8r\",\n            \"koi\",\n            \"koi8\",\n            \"koi8-r\",\n            \"koi8_r\"\n          ],\n          \"name\": \"KOI8-R\"\n        },\n        {\n          \"labels\": [\n            \"koi8-ru\",\n            \"koi8-u\"\n          ],\n          \"name\": \"KOI8-U\"\n        },\n        {\n          \"labels\": [\n            \"csmacintosh\",\n            \"mac\",\n            \"macintosh\",\n            \"x-mac-roman\"\n          ],\n          \"name\": \"macintosh\"\n        },\n        {\n          \"labels\": [\n            \"dos-874\",\n            \"iso-8859-11\",\n            \"iso8859-11\",\n            \"iso885911\",\n            \"tis-620\",\n            \"windows-874\"\n          ],\n          \"name\": \"windows-874\"\n        },\n        {\n          \"labels\": [\n            \"cp1250\",\n            \"windows-1250\",\n            \"x-cp1250\"\n          ],\n          \"name\": \"windows-1250\"\n        },\n        {\n          \"labels\": [\n            \"cp1251\",\n            \"windows-1251\",\n            \"x-cp1251\"\n          ],\n          \"name\": \"windows-1251\"\n        },\n        {\n          \"labels\": [\n            \"ansi_x3.4-1968\",\n            \"ascii\",\n            \"cp1252\",\n            \"cp819\",\n            \"csisolatin1\",\n            \"ibm819\",\n            \"iso-8859-1\",\n            \"iso-ir-100\",\n            \"iso8859-1\",\n            \"iso88591\",\n            \"iso_8859-1\",\n            \"iso_8859-1:1987\",\n            \"l1\",\n            \"latin1\",\n            \"us-ascii\",\n            \"windows-1252\",\n            \"x-cp1252\"\n          ],\n          \"name\": \"windows-1252\"\n        },\n        {\n          \"labels\": [\n            \"cp1253\",\n            \"windows-1253\",\n            \"x-cp1253\"\n          ],\n          \"name\": \"windows-1253\"\n        },\n        {\n          \"labels\": [\n            \"cp1254\",\n            \"csisolatin5\",\n            \"iso-8859-9\",\n            \"iso-ir-148\",\n            \"iso8859-9\",\n            \"iso88599\",\n            \"iso_8859-9\",\n            \"iso_8859-9:1989\",\n            \"l5\",\n            \"latin5\",\n            \"windows-1254\",\n            \"x-cp1254\"\n          ],\n          \"name\": \"windows-1254\"\n        },\n        {\n          \"labels\": [\n            \"cp1255\",\n            \"windows-1255\",\n            \"x-cp1255\"\n          ],\n          \"name\": \"windows-1255\"\n        },\n        {\n          \"labels\": [\n            \"cp1256\",\n            \"windows-1256\",\n            \"x-cp1256\"\n          ],\n          \"name\": \"windows-1256\"\n        },\n        {\n          \"labels\": [\n            \"cp1257\",\n            \"windows-1257\",\n            \"x-cp1257\"\n          ],\n          \"name\": \"windows-1257\"\n        },\n        {\n          \"labels\": [\n            \"cp1258\",\n            \"windows-1258\",\n            \"x-cp1258\"\n          ],\n          \"name\": \"windows-1258\"\n        },\n        {\n          \"labels\": [\n            \"x-mac-cyrillic\",\n            \"x-mac-ukrainian\"\n          ],\n          \"name\": \"x-mac-cyrillic\"\n        }\n      ],\n      \"heading\": \"Legacy single-byte encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"chinese\",\n            \"csgb2312\",\n            \"csiso58gb231280\",\n            \"gb2312\",\n            \"gb_2312\",\n            \"gb_2312-80\",\n            \"gbk\",\n            \"iso-ir-58\",\n            \"x-gbk\"\n          ],\n          \"name\": \"GBK\"\n        },\n        {\n          \"labels\": [\n            \"gb18030\"\n          ],\n          \"name\": \"gb18030\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Chinese (simplified) encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"big5\",\n            \"big5-hkscs\",\n            \"cn-big5\",\n            \"csbig5\",\n            \"x-x-big5\"\n          ],\n          \"name\": \"Big5\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Chinese (traditional) encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"cseucpkdfmtjapanese\",\n            \"euc-jp\",\n            \"x-euc-jp\"\n          ],\n          \"name\": \"EUC-JP\"\n        },\n        {\n          \"labels\": [\n            \"csiso2022jp\",\n            \"iso-2022-jp\"\n          ],\n          \"name\": \"ISO-2022-JP\"\n        },\n        {\n          \"labels\": [\n            \"csshiftjis\",\n            \"ms932\",\n            \"ms_kanji\",\n            \"shift-jis\",\n            \"shift_jis\",\n            \"sjis\",\n            \"windows-31j\",\n            \"x-sjis\"\n          ],\n          \"name\": \"Shift_JIS\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Japanese encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"cseuckr\",\n            \"csksc56011987\",\n            \"euc-kr\",\n            \"iso-ir-149\",\n            \"korean\",\n            \"ks_c_5601-1987\",\n            \"ks_c_5601-1989\",\n            \"ksc5601\",\n            \"ksc_5601\",\n            \"windows-949\"\n          ],\n          \"name\": \"EUC-KR\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Korean encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"csiso2022kr\",\n            \"hz-gb-2312\",\n            \"iso-2022-cn\",\n            \"iso-2022-cn-ext\",\n            \"iso-2022-kr\"\n          ],\n          \"name\": \"replacement\"\n        },\n        {\n          \"labels\": [\n            \"utf-16be\"\n          ],\n          \"name\": \"UTF-16BE\"\n        },\n        {\n          \"labels\": [\n            \"utf-16\",\n            \"utf-16le\"\n          ],\n          \"name\": \"UTF-16LE\"\n        },\n        {\n          \"labels\": [\n            \"x-user-defined\"\n          ],\n          \"name\": \"x-user-defined\"\n        }\n      ],\n      \"heading\": \"Legacy miscellaneous encodings\"\n    }\n  ];\n\n  // Label to encoding registry.\n  /** @type {Object.<string,{name:string,labels:Array.<string>}>} */\n  var label_to_encoding = {};\n  encodings.forEach(function(category) {\n    category.encodings.forEach(function(encoding) {\n      encoding.labels.forEach(function(label) {\n        label_to_encoding[label] = encoding;\n      });\n    });\n  });\n\n  // Registry of of encoder/decoder factories, by encoding name.\n  /** @type {Object.<string, function({fatal:boolean}): Encoder>} */\n  var encoders = {};\n  /** @type {Object.<string, function({fatal:boolean}): Decoder>} */\n  var decoders = {};\n\n  //\n  // 6. Indexes\n  //\n\n  /**\n   * @param {number} pointer The |pointer| to search for.\n   * @param {(!Array.<?number>|undefined)} index The |index| to search within.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in |index|.\n   */\n  function indexCodePointFor(pointer, index) {\n    if (!index) return null;\n    return index[pointer] || null;\n  }\n\n  /**\n   * @param {number} code_point The |code point| to search for.\n   * @param {!Array.<?number>} index The |index| to search within.\n   * @return {?number} The first pointer corresponding to |code point| in\n   *     |index|, or null if |code point| is not in |index|.\n   */\n  function indexPointerFor(code_point, index) {\n    var pointer = index.indexOf(code_point);\n    return pointer === -1 ? null : pointer;\n  }\n\n  /**\n   * @param {string} name Name of the index.\n   * @return {(!Array.<number>|!Array.<Array.<number>>)}\n   *  */\n  function index(name) {\n    if (!('encoding-indexes' in global)) {\n      throw Error(\"Indexes missing.\" +\n                  \" Did you forget to include encoding-indexes.js first?\");\n    }\n    return global['encoding-indexes'][name];\n  }\n\n  /**\n   * @param {number} pointer The |pointer| to search for in the gb18030 index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the gb18030 index.\n   */\n  function indexGB18030RangesCodePointFor(pointer) {\n    // 1. If pointer is greater than 39419 and less than 189000, or\n    // pointer is greater than 1237575, return null.\n    if ((pointer > 39419 && pointer < 189000) || (pointer > 1237575))\n      return null;\n\n    // 2. If pointer is 7457, return code point U+E7C7.\n    if (pointer === 7457) return 0xE7C7;\n\n    // 3. Let offset be the last pointer in index gb18030 ranges that\n    // is equal to or less than pointer and let code point offset be\n    // its corresponding code point.\n    var offset = 0;\n    var code_point_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n      if (entry[0] <= pointer) {\n        offset = entry[0];\n        code_point_offset = entry[1];\n      } else {\n        break;\n      }\n    }\n\n    // 4. Return a code point whose value is code point offset +\n    // pointer − offset.\n    return code_point_offset + pointer - offset;\n  }\n\n  /**\n   * @param {number} code_point The |code point| to locate in the gb18030 index.\n   * @return {number} The first pointer corresponding to |code point| in the\n   *     gb18030 index.\n   */\n  function indexGB18030RangesPointerFor(code_point) {\n    // 1. If code point is U+E7C7, return pointer 7457.\n    if (code_point === 0xE7C7) return 7457;\n\n    // 2. Let offset be the last code point in index gb18030 ranges\n    // that is equal to or less than code point and let pointer offset\n    // be its corresponding pointer.\n    var offset = 0;\n    var pointer_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n      if (entry[1] <= code_point) {\n        offset = entry[1];\n        pointer_offset = entry[0];\n      } else {\n        break;\n      }\n    }\n\n    // 3. Return a pointer whose value is pointer offset + code point\n    // − offset.\n    return pointer_offset + code_point - offset;\n  }\n\n  /**\n   * @param {number} code_point The |code_point| to search for in the Shift_JIS\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the Shift_JIS index.\n   */\n  function indexShiftJISPointerFor(code_point) {\n    // 1. Let index be index jis0208 excluding all entries whose\n    // pointer is in the range 8272 to 8835, inclusive.\n    shift_jis_index = shift_jis_index ||\n      index('jis0208').map(function(code_point, pointer) {\n        return inRange(pointer, 8272, 8835) ? null : code_point;\n      });\n    var index_ = shift_jis_index;\n\n    // 2. Return the index pointer for code point in index.\n    return index_.indexOf(code_point);\n  }\n  var shift_jis_index;\n\n  /**\n   * @param {number} code_point The |code_point| to search for in the big5\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the big5 index.\n   */\n  function indexBig5PointerFor(code_point) {\n    // 1. Let index be index Big5 excluding all entries whose pointer\n    big5_index_no_hkscs = big5_index_no_hkscs ||\n      index('big5').map(function(code_point, pointer) {\n        return (pointer < (0xA1 - 0x81) * 157) ? null : code_point;\n      });\n    var index_ = big5_index_no_hkscs;\n\n    // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\n    // U+5345, return the last pointer corresponding to code point in\n    // index.\n    if (code_point === 0x2550 || code_point === 0x255E ||\n        code_point === 0x2561 || code_point === 0x256A ||\n        code_point === 0x5341 || code_point === 0x5345) {\n      return index_.lastIndexOf(code_point);\n    }\n\n    // 3. Return the index pointer for code point in index.\n    return indexPointerFor(code_point, index_);\n  }\n  var big5_index_no_hkscs;\n\n  //\n  // 8. API\n  //\n\n  /** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n  // 8.1 Interface TextDecoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding;\n   *     defaults to 'utf-8'.\n   * @param {Object=} options\n   */\n  function TextDecoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextDecoder))\n      throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n    options = ToDictionary(options);\n\n    // A TextDecoder object has an associated encoding, decoder,\n    // stream, ignore BOM flag (initially unset), BOM seen flag\n    // (initially unset), error mode (initially replacement), and do\n    // not flush flag (initially unset).\n\n    /** @private */\n    this._encoding = null;\n    /** @private @type {?Decoder} */\n    this._decoder = null;\n    /** @private @type {boolean} */\n    this._ignoreBOM = false;\n    /** @private @type {boolean} */\n    this._BOMseen = false;\n    /** @private @type {string} */\n    this._error_mode = 'replacement';\n    /** @private @type {boolean} */\n    this._do_not_flush = false;\n\n\n    // 1. Let encoding be the result of getting an encoding from\n    // label.\n    var encoding = getEncoding(label);\n\n    // 2. If encoding is failure or replacement, throw a RangeError.\n    if (encoding === null || encoding.name === 'replacement')\n      throw RangeError('Unknown encoding: ' + label);\n    if (!decoders[encoding.name]) {\n      throw Error('Decoder not present.' +\n                  ' Did you forget to include encoding-indexes.js first?');\n    }\n\n    // 3. Let dec be a new TextDecoder object.\n    var dec = this;\n\n    // 4. Set dec's encoding to encoding.\n    dec._encoding = encoding;\n\n    // 5. If options's fatal member is true, set dec's error mode to\n    // fatal.\n    if (Boolean(options['fatal']))\n      dec._error_mode = 'fatal';\n\n    // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n    // flag.\n    if (Boolean(options['ignoreBOM']))\n      dec._ignoreBOM = true;\n\n    // For pre-ES5 runtimes:\n    if (!Object.defineProperty) {\n      this.encoding = dec._encoding.name.toLowerCase();\n      this.fatal = dec._error_mode === 'fatal';\n      this.ignoreBOM = dec._ignoreBOM;\n    }\n\n    // 7. Return dec.\n    return dec;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextDecoder.prototype, 'encoding', {\n      /** @this {TextDecoder} */\n      get: function() { return this._encoding.name.toLowerCase(); }\n    });\n\n    // The fatal attribute's getter must return true if error mode\n    // is fatal, and false otherwise.\n    Object.defineProperty(TextDecoder.prototype, 'fatal', {\n      /** @this {TextDecoder} */\n      get: function() { return this._error_mode === 'fatal'; }\n    });\n\n    // The ignoreBOM attribute's getter must return true if ignore\n    // BOM flag is set, and false otherwise.\n    Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {\n      /** @this {TextDecoder} */\n      get: function() { return this._ignoreBOM; }\n    });\n  }\n\n  /**\n   * @param {BufferSource=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  TextDecoder.prototype.decode = function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options);\n\n    // 1. If the do not flush flag is unset, set decoder to a new\n    // encoding's decoder, set stream to a new stream, and unset the\n    // BOM seen flag.\n    if (!this._do_not_flush) {\n      this._decoder = decoders[this._encoding.name]({\n        fatal: this._error_mode === 'fatal'});\n      this._BOMseen = false;\n    }\n\n    // 2. If options's stream is true, set the do not flush flag, and\n    // unset the do not flush flag otherwise.\n    this._do_not_flush = Boolean(options['stream']);\n\n    // 3. If input is given, push a copy of input to stream.\n    // TODO: Align with spec algorithm - maintain stream on instance.\n    var input_stream = new Stream(bytes);\n\n    // 4. Let output be a new stream.\n    var output = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    // 5. While true:\n    while (true) {\n      // 1. Let token be the result of reading from stream.\n      var token = input_stream.read();\n\n      // 2. If token is end-of-stream and the do not flush flag is\n      // set, return output, serialized.\n      // TODO: Align with spec algorithm.\n      if (token === end_of_stream)\n        break;\n\n      // 3. Otherwise, run these subsubsteps:\n\n      // 1. Let result be the result of processing token for decoder,\n      // stream, output, and error mode.\n      result = this._decoder.handler(input_stream, token);\n\n      // 2. If result is finished, return output, serialized.\n      if (result === finished)\n        break;\n\n      if (result !== null) {\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      }\n\n      // 3. Otherwise, if result is error, throw a TypeError.\n      // (Thrown in handler)\n\n      // 4. Otherwise, do nothing.\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    // A TextDecoder object also has an associated serialize stream\n    // algorithm...\n    /**\n     * @param {!Array.<number>} stream\n     * @return {string}\n     * @this {TextDecoder}\n     */\n    function serializeStream(stream) {\n      // 1. Let token be the result of reading from stream.\n      // (Done in-place on array, rather than as a stream)\n\n      // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n      // BOM flag and BOM seen flag are unset, run these subsubsteps:\n      if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) &&\n          !this._ignoreBOM && !this._BOMseen) {\n        if (stream.length > 0 && stream[0] === 0xFEFF) {\n          // 1. If token is U+FEFF, set BOM seen flag.\n          this._BOMseen = true;\n          stream.shift();\n        } else if (stream.length > 0) {\n          // 2. Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to stream.\n          this._BOMseen = true;\n        } else {\n          // 3. Otherwise, if token is not end-of-stream, append token\n          // to output.\n          // (no-op)\n        }\n      }\n      // 4. Otherwise, return output.\n      return codePointsToString(stream);\n    }\n\n    return serializeStream.call(this, output);\n  };\n\n  // 8.2 Interface TextEncoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding. NONSTANDARD.\n   * @param {Object=} options NONSTANDARD.\n   */\n  function TextEncoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextEncoder))\n      throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    options = ToDictionary(options);\n\n    // A TextEncoder object has an associated encoding and encoder.\n\n    /** @private */\n    this._encoding = null;\n    /** @private @type {?Encoder} */\n    this._encoder = null;\n\n    // Non-standard\n    /** @private @type {boolean} */\n    this._do_not_flush = false;\n    /** @private @type {string} */\n    this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';\n\n    // 1. Let enc be a new TextEncoder object.\n    var enc = this;\n\n    // 2. Set enc's encoding to UTF-8's encoder.\n    if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {\n      // NONSTANDARD behavior.\n      label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n      var encoding = getEncoding(label);\n      if (encoding === null || encoding.name === 'replacement')\n        throw RangeError('Unknown encoding: ' + label);\n      if (!encoders[encoding.name]) {\n        throw Error('Encoder not present.' +\n                    ' Did you forget to include encoding-indexes.js first?');\n      }\n      enc._encoding = encoding;\n    } else {\n      // Standard behavior.\n      enc._encoding = getEncoding('utf-8');\n\n      if (label !== undefined && 'console' in global) {\n        console.warn('TextEncoder constructor called with encoding label, '\n                     + 'which is ignored.');\n      }\n    }\n\n    // For pre-ES5 runtimes:\n    if (!Object.defineProperty)\n      this.encoding = enc._encoding.name.toLowerCase();\n\n    // 3. Return enc.\n    return enc;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextEncoder.prototype, 'encoding', {\n      /** @this {TextEncoder} */\n      get: function() { return this._encoding.name.toLowerCase(); }\n    });\n  }\n\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {!Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  TextEncoder.prototype.encode = function encode(opt_string, options) {\n    opt_string = opt_string === undefined ? '' : String(opt_string);\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\n    // the input is a USVString so streaming is not necessary.\n    if (!this._do_not_flush)\n      this._encoder = encoders[this._encoding.name]({\n        fatal: this._fatal === 'fatal'});\n    this._do_not_flush = Boolean(options['stream']);\n\n    // 1. Convert input to a stream.\n    var input = new Stream(stringToCodePoints(opt_string));\n\n    // 2. Let output be a new stream\n    var output = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    // 3. While true, run these substeps:\n    while (true) {\n      // 1. Let token be the result of reading from input.\n      var token = input.read();\n      if (token === end_of_stream)\n        break;\n      // 2. Let result be the result of processing token for encoder,\n      // input, output.\n      result = this._encoder.handler(input, token);\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        output.push.apply(output, /**@type {!Array.<number>}*/(result));\n      else\n        output.push(result);\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      while (true) {\n        result = this._encoder.handler(input, input.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      }\n      this._encoder = null;\n    }\n    // 3. If result is finished, convert output into a byte sequence,\n    // and then return a Uint8Array object wrapping an ArrayBuffer\n    // containing output.\n    return new Uint8Array(output);\n  };\n\n\n  //\n  // 9. The encoding\n  //\n\n  // 9.1 utf-8\n\n  // 9.1.1 utf-8 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function UTF8Decoder(options) {\n    var fatal = options.fatal;\n\n    // utf-8's decoder's has an associated utf-8 code point, utf-8\n    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n    // lower boundary (initially 0x80), and a utf-8 upper boundary\n    // (initially 0xBF).\n    var /** @type {number} */ utf8_code_point = 0,\n        /** @type {number} */ utf8_bytes_seen = 0,\n        /** @type {number} */ utf8_bytes_needed = 0,\n        /** @type {number} */ utf8_lower_boundary = 0x80,\n        /** @type {number} */ utf8_upper_boundary = 0xBF;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n      // set utf-8 bytes needed to 0 and return error.\n      if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n        utf8_bytes_needed = 0;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 3. If utf-8 bytes needed is 0, based on byte:\n      if (utf8_bytes_needed === 0) {\n\n        // 0x00 to 0x7F\n        if (inRange(bite, 0x00, 0x7F)) {\n          // Return a code point whose value is byte.\n          return bite;\n        }\n\n        // 0xC2 to 0xDF\n        else if (inRange(bite, 0xC2, 0xDF)) {\n          // 1. Set utf-8 bytes needed to 1.\n          utf8_bytes_needed = 1;\n\n          // 2. Set UTF-8 code point to byte & 0x1F.\n          utf8_code_point = bite & 0x1F;\n        }\n\n        // 0xE0 to 0xEF\n        else if (inRange(bite, 0xE0, 0xEF)) {\n          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n          if (bite === 0xE0)\n            utf8_lower_boundary = 0xA0;\n          // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n          if (bite === 0xED)\n            utf8_upper_boundary = 0x9F;\n          // 3. Set utf-8 bytes needed to 2.\n          utf8_bytes_needed = 2;\n          // 4. Set UTF-8 code point to byte & 0xF.\n          utf8_code_point = bite & 0xF;\n        }\n\n        // 0xF0 to 0xF4\n        else if (inRange(bite, 0xF0, 0xF4)) {\n          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n          if (bite === 0xF0)\n            utf8_lower_boundary = 0x90;\n          // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n          if (bite === 0xF4)\n            utf8_upper_boundary = 0x8F;\n          // 3. Set utf-8 bytes needed to 3.\n          utf8_bytes_needed = 3;\n          // 4. Set UTF-8 code point to byte & 0x7.\n          utf8_code_point = bite & 0x7;\n        }\n\n        // Otherwise\n        else {\n          // Return error.\n          return decoderError(fatal);\n        }\n\n        // Return continue.\n        return null;\n      }\n\n      // 4. If byte is not in the range utf-8 lower boundary to utf-8\n      // upper boundary, inclusive, run these substeps:\n      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n\n        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n        // utf-8 upper boundary to 0xBF.\n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n        utf8_lower_boundary = 0x80;\n        utf8_upper_boundary = 0xBF;\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Return error.\n        return decoderError(fatal);\n      }\n\n      // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n      // to 0xBF.\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n      // 0x3F)\n      utf8_code_point = (utf8_code_point << 6) | (bite & 0x3F);\n\n      // 7. Increase utf-8 bytes seen by one.\n      utf8_bytes_seen += 1;\n\n      // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n      // continue.\n      if (utf8_bytes_seen !== utf8_bytes_needed)\n        return null;\n\n      // 9. Let code point be utf-8 code point.\n      var code_point = utf8_code_point;\n\n      // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n      // seen to 0.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n      // 11. Return a code point whose value is code point.\n      return code_point;\n    };\n  }\n\n  // 9.1.2 utf-8 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function UTF8Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Set count and offset based on the range code point is in:\n      var count, offset;\n      // U+0080 to U+07FF, inclusive:\n      if (inRange(code_point, 0x0080, 0x07FF)) {\n        // 1 and 0xC0\n        count = 1;\n        offset = 0xC0;\n      }\n      // U+0800 to U+FFFF, inclusive:\n      else if (inRange(code_point, 0x0800, 0xFFFF)) {\n        // 2 and 0xE0\n        count = 2;\n        offset = 0xE0;\n      }\n      // U+10000 to U+10FFFF, inclusive:\n      else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n        // 3 and 0xF0\n        count = 3;\n        offset = 0xF0;\n      }\n\n      // 4. Let bytes be a byte sequence whose first byte is (code\n      // point >> (6 × count)) + offset.\n      var bytes = [(code_point >> (6 * count)) + offset];\n\n      // 5. Run these substeps while count is greater than 0:\n      while (count > 0) {\n\n        // 1. Set temp to code point >> (6 × (count − 1)).\n        var temp = code_point >> (6 * (count - 1));\n\n        // 2. Append to bytes 0x80 | (temp & 0x3F).\n        bytes.push(0x80 | (temp & 0x3F));\n\n        // 3. Decrease count by one.\n        count -= 1;\n      }\n\n      // 6. Return bytes bytes, in order.\n      return bytes;\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-8'] = function(options) {\n    return new UTF8Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-8'] = function(options) {\n    return new UTF8Decoder(options);\n  };\n\n  //\n  // 10. Legacy single-byte encodings\n  //\n\n  // 10.1 single-byte decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {!Array.<number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  function SingleByteDecoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 3. Let code point be the index code point for byte − 0x80 in\n      // index single-byte.\n      var code_point = index[bite - 0x80];\n\n      // 4. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(fatal);\n\n      // 5. Return a code point whose value is code point.\n      return code_point;\n    };\n  }\n\n  // 10.2 single-byte encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {!Array.<?number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  function SingleByteEncoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index pointer for code point in index\n      // single-byte.\n      var pointer = indexPointerFor(code_point, index);\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        encoderError(code_point);\n\n      // 5. Return a byte whose value is pointer + 0x80.\n      return pointer + 0x80;\n    };\n  }\n\n  (function() {\n    if (!('encoding-indexes' in global))\n      return;\n    encodings.forEach(function(category) {\n      if (category.heading !== 'Legacy single-byte encodings')\n        return;\n      category.encodings.forEach(function(encoding) {\n        var name = encoding.name;\n        var idx = index(name.toLowerCase());\n        /** @param {{fatal: boolean}} options */\n        decoders[name] = function(options) {\n          return new SingleByteDecoder(idx, options);\n        };\n        /** @param {{fatal: boolean}} options */\n        encoders[name] = function(options) {\n          return new SingleByteEncoder(idx, options);\n        };\n      });\n    });\n  }());\n\n  //\n  // 11. Legacy multi-byte Chinese (simplified) encodings\n  //\n\n  // 11.1 gbk\n\n  // 11.1.1 gbk decoder\n  // gbk's decoder is gb18030's decoder.\n  /** @param {{fatal: boolean}} options */\n  decoders['GBK'] = function(options) {\n    return new GB18030Decoder(options);\n  };\n\n  // 11.1.2 gbk encoder\n  // gbk's encoder is gb18030's encoder with its gbk flag set.\n  /** @param {{fatal: boolean}} options */\n  encoders['GBK'] = function(options) {\n    return new GB18030Encoder(options, true);\n  };\n\n  // 11.2 gb18030\n\n  // 11.2.1 gb18030 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function GB18030Decoder(options) {\n    var fatal = options.fatal;\n    // gb18030's decoder has an associated gb18030 first, gb18030\n    // second, and gb18030 third (all initially 0x00).\n    var /** @type {number} */ gb18030_first = 0x00,\n        /** @type {number} */ gb18030_second = 0x00,\n        /** @type {number} */ gb18030_third = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and gb18030 first, gb18030\n      // second, and gb18030 third are 0x00, return finished.\n      if (bite === end_of_stream && gb18030_first === 0x00 &&\n          gb18030_second === 0x00 && gb18030_third === 0x00) {\n        return finished;\n      }\n      // 2. If byte is end-of-stream, and gb18030 first, gb18030\n      // second, or gb18030 third is not 0x00, set gb18030 first,\n      // gb18030 second, and gb18030 third to 0x00, and return error.\n      if (bite === end_of_stream &&\n          (gb18030_first !== 0x00 || gb18030_second !== 0x00 ||\n           gb18030_third !== 0x00)) {\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n        decoderError(fatal);\n      }\n      var code_point;\n      // 3. If gb18030 third is not 0x00, run these substeps:\n      if (gb18030_third !== 0x00) {\n        // 1. Let code point be null.\n        code_point = null;\n        // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n        // code point to the index gb18030 ranges code point for\n        // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×\n        // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.\n        if (inRange(bite, 0x30, 0x39)) {\n          code_point = indexGB18030RangesCodePointFor(\n              (((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 +\n               gb18030_third - 0x81) * 10 + bite - 0x30);\n        }\n\n        // 3. Let buffer be a byte sequence consisting of gb18030\n        // second, gb18030 third, and byte, in order.\n        var buffer = [gb18030_second, gb18030_third, bite];\n\n        // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n        // 0x00.\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n\n        // 5. If code point is null, prepend buffer to stream and\n        // return error.\n        if (code_point === null) {\n          stream.prepend(buffer);\n          return decoderError(fatal);\n        }\n\n        // 6. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If gb18030 second is not 0x00, run these substeps:\n      if (gb18030_second !== 0x00) {\n\n        // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n        // gb18030 third to byte and return continue.\n        if (inRange(bite, 0x81, 0xFE)) {\n          gb18030_third = bite;\n          return null;\n        }\n\n        // 2. Prepend gb18030 second followed by byte to stream, set\n        // gb18030 first and gb18030 second to 0x00, and return error.\n        stream.prepend([gb18030_second, bite]);\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 5. If gb18030 first is not 0x00, run these substeps:\n      if (gb18030_first !== 0x00) {\n\n        // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n        // gb18030 second to byte and return continue.\n        if (inRange(bite, 0x30, 0x39)) {\n          gb18030_second = bite;\n          return null;\n        }\n\n        // 2. Let lead be gb18030 first, let pointer be null, and set\n        // gb18030 first to 0x00.\n        var lead = gb18030_first;\n        var pointer = null;\n        gb18030_first = 0x00;\n\n        // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n        // otherwise.\n        var offset = bite < 0x7F ? 0x40 : 0x41;\n\n        // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +\n        // (byte − offset).\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE))\n          pointer = (lead - 0x81) * 190 + (bite - offset);\n\n        // 5. Let code point be null if pointer is null and the index\n        // code point for pointer in index gb18030 otherwise.\n        code_point = pointer === null ? null :\n            indexCodePointFor(pointer, index('gb18030'));\n\n        // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 7. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 8. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 7. If byte is 0x80, return code point U+20AC.\n      if (bite === 0x80)\n        return 0x20AC;\n\n      // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 first to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        gb18030_first = bite;\n        return null;\n      }\n\n      // 9. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 11.2.2 gb18030 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   * @param {boolean=} gbk_flag\n   */\n  function GB18030Encoder(options, gbk_flag) {\n    var fatal = options.fatal;\n    // gb18030's decoder has an associated gbk flag (initially unset).\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is U+E5E5, return error with code point.\n      if (code_point === 0xE5E5)\n        return encoderError(code_point);\n\n      // 4. If the gbk flag is set and code point is U+20AC, return\n      // byte 0x80.\n      if (gbk_flag && code_point === 0x20AC)\n        return 0x80;\n\n      // 5. Let pointer be the index pointer for code point in index\n      // gb18030.\n      var pointer = indexPointerFor(code_point, index('gb18030'));\n\n      // 6. If pointer is not null, run these substeps:\n      if (pointer !== null) {\n\n        // 1. Let lead be floor(pointer / 190) + 0x81.\n        var lead = floor(pointer / 190) + 0x81;\n\n        // 2. Let trail be pointer % 190.\n        var trail = pointer % 190;\n\n        // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n        var offset = trail < 0x3F ? 0x40 : 0x41;\n\n        // 4. Return two bytes whose values are lead and trail + offset.\n        return [lead, trail + offset];\n      }\n\n      // 7. If gbk flag is set, return error with code point.\n      if (gbk_flag)\n        return encoderError(code_point);\n\n      // 8. Set pointer to the index gb18030 ranges pointer for code\n      // point.\n      pointer = indexGB18030RangesPointerFor(code_point);\n\n      // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n      var byte1 = floor(pointer / 10 / 126 / 10);\n\n      // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\n      pointer = pointer - byte1 * 10 * 126 * 10;\n\n      // 11. Let byte2 be floor(pointer / 10 / 126).\n      var byte2 = floor(pointer / 10 / 126);\n\n      // 12. Set pointer to pointer − byte2 × 10 × 126.\n      pointer = pointer - byte2 * 10 * 126;\n\n      // 13. Let byte3 be floor(pointer / 10).\n      var byte3 = floor(pointer / 10);\n\n      // 14. Let byte4 be pointer − byte3 × 10.\n      var byte4 = pointer - byte3 * 10;\n\n      // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n      // 0x30, byte3 + 0x81, byte4 + 0x30.\n      return [byte1 + 0x81,\n              byte2 + 0x30,\n              byte3 + 0x81,\n              byte4 + 0x30];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['gb18030'] = function(options) {\n    return new GB18030Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['gb18030'] = function(options) {\n    return new GB18030Decoder(options);\n  };\n\n\n  //\n  // 12. Legacy multi-byte Chinese (traditional) encodings\n  //\n\n  // 12.1 Big5\n\n  // 12.1.1 Big5 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function Big5Decoder(options) {\n    var fatal = options.fatal;\n    // Big5's decoder has an associated Big5 lead (initially 0x00).\n    var /** @type {number} */ Big5_lead = 0x00;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n      // Big5 lead to 0x00 and return error.\n      if (bite === end_of_stream && Big5_lead !== 0x00) {\n        Big5_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && Big5_lead === 0x00)\n        return finished;\n\n      // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n      // pointer be null, set Big5 lead to 0x00, and then run these\n      // substeps:\n      if (Big5_lead !== 0x00) {\n        var lead = Big5_lead;\n        var pointer = null;\n        Big5_lead = 0x00;\n\n        // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n        // otherwise.\n        var offset = bite < 0x7F ? 0x40 : 0x62;\n\n        // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +\n        // (byte − offset).\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE))\n          pointer = (lead - 0x81) * 157 + (bite - offset);\n\n        // 3. If there is a row in the table below whose first column\n        // is pointer, return the two code points listed in its second\n        // column\n        // Pointer | Code points\n        // --------+--------------\n        // 1133    | U+00CA U+0304\n        // 1135    | U+00CA U+030C\n        // 1164    | U+00EA U+0304\n        // 1166    | U+00EA U+030C\n        switch (pointer) {\n          case 1133: return [0x00CA, 0x0304];\n          case 1135: return [0x00CA, 0x030C];\n          case 1164: return [0x00EA, 0x0304];\n          case 1166: return [0x00EA, 0x030C];\n        }\n\n        // 4. Let code point be null if pointer is null and the index\n        // code point for pointer in index Big5 otherwise.\n        var code_point = (pointer === null) ? null :\n            indexCodePointFor(pointer, index('big5'));\n\n        // 5. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 6. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 7. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n      // lead to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        Big5_lead = bite;\n        return null;\n      }\n\n      // 6. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 12.1.2 Big5 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function Big5Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index Big5 pointer for code point.\n      var pointer = indexBig5PointerFor(code_point);\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 5. Let lead be floor(pointer / 157) + 0x81.\n      var lead = floor(pointer / 157) + 0x81;\n\n      // 6. If lead is less than 0xA1, return error with code point.\n      if (lead < 0xA1)\n        return encoderError(code_point);\n\n      // 7. Let trail be pointer % 157.\n      var trail = pointer % 157;\n\n      // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n      // otherwise.\n      var offset = trail < 0x3F ? 0x40 : 0x62;\n\n      // Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['Big5'] = function(options) {\n    return new Big5Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['Big5'] = function(options) {\n    return new Big5Decoder(options);\n  };\n\n\n  //\n  // 13. Legacy multi-byte Japanese encodings\n  //\n\n  // 13.1 euc-jp\n\n  // 13.1.1 euc-jp decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCJPDecoder(options) {\n    var fatal = options.fatal;\n\n    // euc-jp's decoder has an associated euc-jp jis0212 flag\n    // (initially unset) and euc-jp lead (initially 0x00).\n    var /** @type {boolean} */ eucjp_jis0212_flag = false,\n        /** @type {number} */ eucjp_lead = 0x00;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n      // euc-jp lead to 0x00, and return error.\n      if (bite === end_of_stream && eucjp_lead !== 0x00) {\n        eucjp_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && eucjp_lead === 0x00)\n        return finished;\n\n      // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n      // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n      // point whose value is 0xFF61 − 0xA1 + byte.\n      if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {\n        eucjp_lead = 0x00;\n        return 0xFF61 - 0xA1 + bite;\n      }\n\n      // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n      // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n      // to byte, and return continue.\n      if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {\n        eucjp_jis0212_flag = true;\n        eucjp_lead = bite;\n        return null;\n      }\n\n      // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n      // euc-jp lead to 0x00, and run these substeps:\n      if (eucjp_lead !== 0x00) {\n        var lead = eucjp_lead;\n        eucjp_lead = 0x00;\n\n        // 1. Let code point be null.\n        var code_point = null;\n\n        // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n        // inclusive, set code point to the index code point for (lead\n        // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp\n        // jis0212 flag is unset and in index jis0212 otherwise.\n        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n          code_point = indexCodePointFor(\n            (lead - 0xA1) * 94 + (bite - 0xA1),\n            index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));\n        }\n\n        // 3. Unset the euc-jp jis0212 flag.\n        eucjp_jis0212_flag = false;\n\n        // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n        // prepend byte to stream.\n        if (!inRange(bite, 0xA1, 0xFE))\n          stream.prepend(bite);\n\n        // 5. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 6. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n      // inclusive, set euc-jp lead to byte and return continue.\n      if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\n        eucjp_lead = bite;\n        return null;\n      }\n\n      // 8. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 13.1.2 euc-jp encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCJPEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5)\n        return 0x5C;\n\n      // 4. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E)\n        return 0x7E;\n\n      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return two bytes whose values are 0x8E and code point −\n      // 0xFF61 + 0xA1.\n      if (inRange(code_point, 0xFF61, 0xFF9F))\n        return [0x8E, code_point - 0xFF61 + 0xA1];\n\n      // 6. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 7. Let pointer be the index pointer for code point in index\n      // jis0208.\n      var pointer = indexPointerFor(code_point, index('jis0208'));\n\n      // 8. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 9. Let lead be floor(pointer / 94) + 0xA1.\n      var lead = floor(pointer / 94) + 0xA1;\n\n      // 10. Let trail be pointer % 94 + 0xA1.\n      var trail = pointer % 94 + 0xA1;\n\n      // 11. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['EUC-JP'] = function(options) {\n    return new EUCJPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['EUC-JP'] = function(options) {\n    return new EUCJPDecoder(options);\n  };\n\n  // 13.2 iso-2022-jp\n\n  // 13.2.1 iso-2022-jp decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ISO2022JPDecoder(options) {\n    var fatal = options.fatal;\n    /** @enum */\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      Katakana: 2,\n      LeadByte: 3,\n      TrailByte: 4,\n      EscapeStart: 5,\n      Escape: 6\n    };\n    // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n    // state (initially ASCII), iso-2022-jp decoder output state\n    // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n    // iso-2022-jp output flag (initially unset).\n    var /** @type {number} */ iso2022jp_decoder_state = states.ASCII,\n        /** @type {number} */ iso2022jp_decoder_output_state = states.ASCII,\n        /** @type {number} */ iso2022jp_lead = 0x00,\n        /** @type {boolean} */ iso2022jp_output_flag = false;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // switching on iso-2022-jp decoder state:\n      switch (iso2022jp_decoder_state) {\n      default:\n      case states.ASCII:\n        // ASCII\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E\n            && bite !== 0x0F && bite !== 0x1B) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Roman:\n        // Roman\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x5C\n        if (bite === 0x5C) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+00A5.\n          iso2022jp_output_flag = false;\n          return 0x00A5;\n        }\n\n        // 0x7E\n        if (bite === 0x7E) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+203E.\n          iso2022jp_output_flag = false;\n          return 0x203E;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F\n            && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Katakana:\n        // Katakana\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x5F\n        if (inRange(bite, 0x21, 0x5F)) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is 0xFF61 − 0x21 + byte.\n          iso2022jp_output_flag = false;\n          return 0xFF61 - 0x21 + bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.LeadByte:\n        // Lead byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7E)) {\n          // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n          // to byte, iso-2022-jp decoder state to trail byte, and\n          // return continue.\n          iso2022jp_output_flag = false;\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.TrailByte;\n          return null;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.TrailByte:\n        // Trail byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return decoderError(fatal);\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7E)) {\n          // 1. Set the iso-2022-jp decoder state to lead byte.\n          iso2022jp_decoder_state = states.LeadByte;\n\n          // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\n          var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;\n\n          // 3. Let code point be the index code point for pointer in\n          // index jis0208.\n          var code_point = indexCodePointFor(pointer, index('jis0208'));\n\n          // 4. If code point is null, return error.\n          if (code_point === null)\n            return decoderError(fatal);\n\n          // 5. Return a code point whose value is code point.\n          return code_point;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Set the iso-2022-jp decoder state to lead byte, prepend\n          // byte to stream, and return error.\n          iso2022jp_decoder_state = states.LeadByte;\n          stream.prepend(bite);\n          return decoderError(fatal);\n        }\n\n        // Otherwise\n        // Set iso-2022-jp decoder state to lead byte and return\n        // error.\n        iso2022jp_decoder_state = states.LeadByte;\n        return decoderError(fatal);\n\n      case states.EscapeStart:\n        // Escape start\n\n        // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n        // byte, iso-2022-jp decoder state to escape, and return\n        // continue.\n        if (bite === 0x24 || bite === 0x28) {\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.Escape;\n          return null;\n        }\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state, and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n\n      case states.Escape:\n        // Escape\n\n        // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n        // 0x00.\n        var lead = iso2022jp_lead;\n        iso2022jp_lead = 0x00;\n\n        // 2. Let state be null.\n        var state = null;\n\n        // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n        if (lead === 0x28 && bite === 0x42)\n          state = states.ASCII;\n\n        // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n        if (lead === 0x28 && bite === 0x4A)\n          state = states.Roman;\n\n        // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n        if (lead === 0x28 && bite === 0x49)\n          state = states.Katakana;\n\n        // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n        // state to lead byte.\n        if (lead === 0x24 && (bite === 0x40 || bite === 0x42))\n          state = states.LeadByte;\n\n        // 7. If state is non-null, run these substeps:\n        if (state !== null) {\n          // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n          // output state to states.\n          iso2022jp_decoder_state = iso2022jp_decoder_state = state;\n\n          // 2. Let output flag be the iso-2022-jp output flag.\n          var output_flag = iso2022jp_output_flag;\n\n          // 3. Set the iso-2022-jp output flag.\n          iso2022jp_output_flag = true;\n\n          // 4. Return continue, if output flag is unset, and error\n          // otherwise.\n          return !output_flag ? null : decoderError(fatal);\n        }\n\n        // 8. Prepend lead and byte to stream.\n        stream.prepend([lead, bite]);\n\n        // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n      }\n    };\n  }\n\n  // 13.2.2 iso-2022-jp encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ISO2022JPEncoder(options) {\n    var fatal = options.fatal;\n    // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n    // state which is one of ASCII, Roman, and jis0208 (initially\n    // ASCII).\n    /** @enum */\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      jis0208: 2\n    };\n    var /** @type {number} */ iso2022jp_state = states.ASCII;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream and iso-2022-jp encoder\n      // state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (code_point === end_of_stream &&\n          iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n\n      // 2. If code point is end-of-stream and iso-2022-jp encoder\n      // state is ASCII, return finished.\n      if (code_point === end_of_stream && iso2022jp_state === states.ASCII)\n        return finished;\n\n      // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n      // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n      if ((iso2022jp_state === states.ASCII ||\n           iso2022jp_state === states.Roman) &&\n          (code_point === 0x000E || code_point === 0x000F ||\n           code_point === 0x001B)) {\n        return encoderError(0xFFFD);\n      }\n\n      // 4. If iso-2022-jp encoder state is ASCII and code point is an\n      // ASCII code point, return a byte whose value is code point.\n      if (iso2022jp_state === states.ASCII &&\n          isASCIICodePoint(code_point))\n        return code_point;\n\n      // 5. If iso-2022-jp encoder state is Roman and code point is an\n      // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n      // or U+203E, run these substeps:\n      if (iso2022jp_state === states.Roman &&\n          ((isASCIICodePoint(code_point) &&\n           code_point !== 0x005C && code_point !== 0x007E) ||\n          (code_point == 0x00A5 || code_point == 0x203E))) {\n\n        // 1. If code point is an ASCII code point, return a byte\n        // whose value is code point.\n        if (isASCIICodePoint(code_point))\n          return code_point;\n\n        // 2. If code point is U+00A5, return byte 0x5C.\n        if (code_point === 0x00A5)\n          return 0x5C;\n\n        // 3. If code point is U+203E, return byte 0x7E.\n        if (code_point === 0x203E)\n          return 0x7E;\n      }\n\n      // 6. If code point is an ASCII code point, and iso-2022-jp\n      // encoder state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (isASCIICodePoint(code_point) &&\n          iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n\n      // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n      // encoder state is not Roman, prepend code point to stream, set\n      // iso-2022-jp encoder state to Roman, and return three bytes\n      // 0x1B 0x28 0x4A.\n      if ((code_point === 0x00A5 || code_point === 0x203E) &&\n          iso2022jp_state !== states.Roman) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.Roman;\n        return [0x1B, 0x28, 0x4A];\n      }\n\n      // 8. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 9. Let pointer be the index pointer for code point in index\n      // jis0208.\n      var pointer = indexPointerFor(code_point, index('jis0208'));\n\n      // 10. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n      // point to stream, set iso-2022-jp encoder state to jis0208,\n      // and return three bytes 0x1B 0x24 0x42.\n      if (iso2022jp_state !== states.jis0208) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.jis0208;\n        return [0x1B, 0x24, 0x42];\n      }\n\n      // 12. Let lead be floor(pointer / 94) + 0x21.\n      var lead = floor(pointer / 94) + 0x21;\n\n      // 13. Let trail be pointer % 94 + 0x21.\n      var trail = pointer % 94 + 0x21;\n\n      // 14. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['ISO-2022-JP'] = function(options) {\n    return new ISO2022JPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['ISO-2022-JP'] = function(options) {\n    return new ISO2022JPDecoder(options);\n  };\n\n  // 13.3 Shift_JIS\n\n  // 13.3.1 Shift_JIS decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ShiftJISDecoder(options) {\n    var fatal = options.fatal;\n    // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n    // 0x00).\n    var /** @type {number} */ Shift_JIS_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n      // set Shift_JIS lead to 0x00 and return error.\n      if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {\n        Shift_JIS_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n      // return finished.\n      if (bite === end_of_stream && Shift_JIS_lead === 0x00)\n        return finished;\n\n      // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n      // let pointer be null, set Shift_JIS lead to 0x00, and then run\n      // these substeps:\n      if (Shift_JIS_lead !== 0x00) {\n        var lead = Shift_JIS_lead;\n        var pointer = null;\n        Shift_JIS_lead = 0x00;\n\n        // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n        // otherwise.\n        var offset = (bite < 0x7F) ? 0x40 : 0x41;\n\n        // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n        // 0xC1 otherwise.\n        var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1;\n\n        // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFC, inclusive, set pointer to (lead − lead offset) ×\n        // 188 + byte − offset.\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC))\n          pointer = (lead - lead_offset) * 188 + bite - offset;\n\n        // 4. If pointer is in the range 8836 to 10715, inclusive,\n        // return a code point whose value is 0xE000 − 8836 + pointer.\n        if (inRange(pointer, 8836, 10715))\n          return 0xE000 - 8836 + pointer;\n\n        // 5. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index jis0208 otherwise.\n        var code_point = (pointer === null) ? null :\n              indexCodePointFor(pointer, index('jis0208'));\n\n        // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 7. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 8. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte or 0x80, return a code point\n      // whose value is byte.\n      if (isASCIIByte(bite) || bite === 0x80)\n        return bite;\n\n      // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n      // code point whose value is 0xFF61 − 0xA1 + byte.\n      if (inRange(bite, 0xA1, 0xDF))\n        return 0xFF61 - 0xA1 + bite;\n\n      // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n      // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n      // continue.\n      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\n        Shift_JIS_lead = bite;\n        return null;\n      }\n\n      // 7. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 13.3.2 Shift_JIS encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ShiftJISEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point or U+0080, return a\n      // byte whose value is code point.\n      if (isASCIICodePoint(code_point) || code_point === 0x0080)\n        return code_point;\n\n      // 3. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5)\n        return 0x5C;\n\n      // 4. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E)\n        return 0x7E;\n\n      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return a byte whose value is code point − 0xFF61 + 0xA1.\n      if (inRange(code_point, 0xFF61, 0xFF9F))\n        return code_point - 0xFF61 + 0xA1;\n\n      // 6. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 7. Let pointer be the index Shift_JIS pointer for code point.\n      var pointer = indexShiftJISPointerFor(code_point);\n\n      // 8. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 9. Let lead be floor(pointer / 188).\n      var lead = floor(pointer / 188);\n\n      // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n      // 0xC1 otherwise.\n      var lead_offset = (lead < 0x1F) ? 0x81 : 0xC1;\n\n      // 11. Let trail be pointer % 188.\n      var trail = pointer % 188;\n\n      // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n      // otherwise.\n      var offset = (trail < 0x3F) ? 0x40 : 0x41;\n\n      // 13. Return two bytes whose values are lead + lead offset and\n      // trail + offset.\n      return [lead + lead_offset, trail + offset];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['Shift_JIS'] = function(options) {\n    return new ShiftJISEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['Shift_JIS'] = function(options) {\n    return new ShiftJISDecoder(options);\n  };\n\n  //\n  // 14. Legacy multi-byte Korean encodings\n  //\n\n  // 14.1 euc-kr\n\n  // 14.1.1 euc-kr decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCKRDecoder(options) {\n    var fatal = options.fatal;\n\n    // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n    var /** @type {number} */ euckr_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n      // euc-kr lead to 0x00 and return error.\n      if (bite === end_of_stream && euckr_lead !== 0) {\n        euckr_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && euckr_lead === 0)\n        return finished;\n\n      // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n      // pointer be null, set euc-kr lead to 0x00, and then run these\n      // substeps:\n      if (euckr_lead !== 0x00) {\n        var lead = euckr_lead;\n        var pointer = null;\n        euckr_lead = 0x00;\n\n        // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n        // pointer to (lead − 0x81) × 190 + (byte − 0x41).\n        if (inRange(bite, 0x41, 0xFE))\n          pointer = (lead - 0x81) * 190 + (bite - 0x41);\n\n        // 2. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index euc-kr otherwise.\n        var code_point = (pointer === null)\n              ? null : indexCodePointFor(pointer, index('euc-kr'));\n\n        // 3. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (pointer === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 4. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 5. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // euc-kr lead to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        euckr_lead = bite;\n        return null;\n      }\n\n      // 6. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 14.1.2 euc-kr encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCKREncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index pointer for code point in index\n      // euc-kr.\n      var pointer = indexPointerFor(code_point, index('euc-kr'));\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 5. Let lead be floor(pointer / 190) + 0x81.\n      var lead = floor(pointer / 190) + 0x81;\n\n      // 6. Let trail be pointer % 190 + 0x41.\n      var trail = (pointer % 190) + 0x41;\n\n      // 7. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['EUC-KR'] = function(options) {\n    return new EUCKREncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['EUC-KR'] = function(options) {\n    return new EUCKRDecoder(options);\n  };\n\n\n  //\n  // 15. Legacy miscellaneous encodings\n  //\n\n  // 15.1 replacement\n\n  // Not needed - API throws RangeError\n\n  // 15.2 Common infrastructure for utf-16be and utf-16le\n\n  /**\n   * @param {number} code_unit\n   * @param {boolean} utf16be\n   * @return {!Array.<number>} bytes\n   */\n  function convertCodeUnitToBytes(code_unit, utf16be) {\n    // 1. Let byte1 be code unit >> 8.\n    var byte1 = code_unit >> 8;\n\n    // 2. Let byte2 be code unit & 0x00FF.\n    var byte2 = code_unit & 0x00FF;\n\n    // 3. Then return the bytes in order:\n        // utf-16be flag is set: byte1, then byte2.\n    if (utf16be)\n      return [byte1, byte2];\n    // utf-16be flag is unset: byte2, then byte1.\n    return [byte2, byte1];\n  }\n\n  // 15.2.1 shared utf-16 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n  function UTF16Decoder(utf16_be, options) {\n    var fatal = options.fatal;\n    var /** @type {?number} */ utf16_lead_byte = null,\n        /** @type {?number} */ utf16_lead_surrogate = null;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and either utf-16 lead byte or\n      // utf-16 lead surrogate is not null, set utf-16 lead byte and\n      // utf-16 lead surrogate to null, and return error.\n      if (bite === end_of_stream && (utf16_lead_byte !== null ||\n                                utf16_lead_surrogate !== null)) {\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\n      // lead surrogate are null, return finished.\n      if (bite === end_of_stream && utf16_lead_byte === null &&\n          utf16_lead_surrogate === null) {\n        return finished;\n      }\n\n      // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\n      // and return continue.\n      if (utf16_lead_byte === null) {\n        utf16_lead_byte = bite;\n        return null;\n      }\n\n      // 4. Let code unit be the result of:\n      var code_unit;\n      if (utf16_be) {\n        // utf-16be decoder flag is set\n        //   (utf-16 lead byte << 8) + byte.\n        code_unit = (utf16_lead_byte << 8) + bite;\n      } else {\n        // utf-16be decoder flag is unset\n        //   (byte << 8) + utf-16 lead byte.\n        code_unit = (bite << 8) + utf16_lead_byte;\n      }\n      // Then set utf-16 lead byte to null.\n      utf16_lead_byte = null;\n\n      // 5. If utf-16 lead surrogate is not null, let lead surrogate\n      // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\n      // and then run these substeps:\n      if (utf16_lead_surrogate !== null) {\n        var lead_surrogate = utf16_lead_surrogate;\n        utf16_lead_surrogate = null;\n\n        // 1. If code unit is in the range U+DC00 to U+DFFF,\n        // inclusive, return a code point whose value is 0x10000 +\n        // ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).\n        if (inRange(code_unit, 0xDC00, 0xDFFF)) {\n          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 +\n              (code_unit - 0xDC00);\n        }\n\n        // 2. Prepend the sequence resulting of converting code unit\n        // to bytes using utf-16be decoder flag to stream and return\n        // error.\n        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\n        return decoderError(fatal);\n      }\n\n      // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,\n      // set utf-16 lead surrogate to code unit and return continue.\n      if (inRange(code_unit, 0xD800, 0xDBFF)) {\n        utf16_lead_surrogate = code_unit;\n        return null;\n      }\n\n      // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,\n      // return error.\n      if (inRange(code_unit, 0xDC00, 0xDFFF))\n        return decoderError(fatal);\n\n      // 8. Return code point code unit.\n      return code_unit;\n    };\n  }\n\n  // 15.2.2 shared utf-16 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n  function UTF16Encoder(utf16_be, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is in the range U+0000 to U+FFFF, inclusive,\n      // return the sequence resulting of converting code point to\n      // bytes using utf-16be encoder flag.\n      if (inRange(code_point, 0x0000, 0xFFFF))\n        return convertCodeUnitToBytes(code_point, utf16_be);\n\n      // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,\n      // converted to bytes using utf-16be encoder flag.\n      var lead = convertCodeUnitToBytes(\n        ((code_point - 0x10000) >> 10) + 0xD800, utf16_be);\n\n      // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,\n      // converted to bytes using utf-16be encoder flag.\n      var trail = convertCodeUnitToBytes(\n        ((code_point - 0x10000) & 0x3FF) + 0xDC00, utf16_be);\n\n      // 5. Return a byte sequence of lead followed by trail.\n      return lead.concat(trail);\n    };\n  }\n\n  // 15.3 utf-16be\n  // 15.3.1 utf-16be decoder\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-16BE'] = function(options) {\n    return new UTF16Encoder(true, options);\n  };\n  // 15.3.2 utf-16be encoder\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-16BE'] = function(options) {\n    return new UTF16Decoder(true, options);\n  };\n\n  // 15.4 utf-16le\n  // 15.4.1 utf-16le decoder\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-16LE'] = function(options) {\n    return new UTF16Encoder(false, options);\n  };\n  // 15.4.2 utf-16le encoder\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-16LE'] = function(options) {\n    return new UTF16Decoder(false, options);\n  };\n\n  // 15.5 x-user-defined\n\n  // 15.5.1 x-user-defined decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function XUserDefinedDecoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 3. Return a code point whose value is 0xF780 + byte − 0x80.\n      return 0xF780 + bite - 0x80;\n    };\n  }\n\n  // 15.5.2 x-user-defined encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function XUserDefinedEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1.If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is in the range U+F780 to U+F7FF, inclusive,\n      // return a byte whose value is code point − 0xF780 + 0x80.\n      if (inRange(code_point, 0xF780, 0xF7FF))\n        return code_point - 0xF780 + 0x80;\n\n      // 4. Return error with code point.\n      return encoderError(code_point);\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['x-user-defined'] = function(options) {\n    return new XUserDefinedEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['x-user-defined'] = function(options) {\n    return new XUserDefinedDecoder(options);\n  };\n\n  if (!global['TextEncoder'])\n    global['TextEncoder'] = TextEncoder;\n  if (!global['TextDecoder'])\n    global['TextDecoder'] = TextDecoder;\n\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = {\n      TextEncoder: global['TextEncoder'],\n      TextDecoder: global['TextDecoder'],\n      EncodingIndexes: global[\"encoding-indexes\"]\n    };\n  }\n\n// For strict environments where `this` inside the global scope\n// is `undefined`, take a pure object instead\n}(this || {}));"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}