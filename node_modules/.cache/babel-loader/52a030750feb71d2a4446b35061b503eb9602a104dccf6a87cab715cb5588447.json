{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.convert = exports.encode = exports.decode = undefined;\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nexports.mimeEncode = mimeEncode;\nexports.mimeDecode = mimeDecode;\nexports.base64Encode = base64Encode;\nexports.base64Decode = base64Decode;\nexports.quotedPrintableEncode = quotedPrintableEncode;\nexports.quotedPrintableDecode = quotedPrintableDecode;\nexports.mimeWordEncode = mimeWordEncode;\nexports.mimeWordsEncode = mimeWordsEncode;\nexports.mimeWordDecode = mimeWordDecode;\nexports.mimeWordsDecode = mimeWordsDecode;\nexports.foldLines = foldLines;\nexports.headerLineEncode = headerLineEncode;\nexports.headerLineDecode = headerLineDecode;\nexports.headerLinesDecode = headerLinesDecode;\nexports.parseHeaderValue = parseHeaderValue;\nexports.continuationEncode = continuationEncode;\nvar _emailjsBase = require('emailjs-base64');\nvar _charset = require('./charset');\nvar _ramda = require('ramda');\n\n// Lines can't be longer than 76 + <CR><LF> = 78 bytes\n// http://tools.ietf.org/html/rfc2045#section-6.7\nvar MAX_LINE_LENGTH = 76;\nvar MAX_MIME_WORD_LENGTH = 52;\nvar MAX_B64_MIME_WORD_BYTE_LENGTH = 39;\n\n/**\n * Encodes all non printable and non ascii bytes to =XX form, where XX is the\n * byte value in hex. This function does not convert linebreaks etc. it\n * only escapes character sequences\n *\n * @param {String|Uint8Array} data Either a string or an Uint8Array\n * @param {String} [fromCharset='UTF-8'] Source encoding\n * @return {String} Mime encoded string\n */\nfunction mimeEncode() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var buffer = (0, _charset.convert)(data, fromCharset);\n  return buffer.reduce(function (aggregate, ord, index) {\n    return _checkRanges(ord) && !((ord === 0x20 || ord === 0x09) && (index === buffer.length - 1 || buffer[index + 1] === 0x0a || buffer[index + 1] === 0x0d)) ? aggregate + String.fromCharCode(ord) // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n    : aggregate + '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();\n  }, '');\n  function _checkRanges(nr) {\n    var ranges = [\n    // https://tools.ietf.org/html/rfc2045#section-6.7\n    [0x09],\n    // <TAB>\n    [0x0A],\n    // <LF>\n    [0x0D],\n    // <CR>\n    [0x20, 0x3C],\n    // <SP>!\"#$%&'()*+,-./0123456789:;\n    [0x3E, 0x7E] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n    ];\n    return ranges.reduce(function (val, range) {\n      return val || range.length === 1 && nr === range[0] || range.length === 2 && nr >= range[0] && nr <= range[1];\n    }, false);\n  }\n}\n\n/**\n * Decodes mime encoded string to an unicode string\n *\n * @param {String} str Mime encoded string\n * @param {String} [fromCharset='UTF-8'] Source encoding\n * @return {String} Decoded unicode string\n */\nfunction mimeDecode() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var encodedBytesCount = (str.match(/=[\\da-fA-F]{2}/g) || []).length;\n  var buffer = new Uint8Array(str.length - encodedBytesCount * 2);\n  for (var i = 0, len = str.length, bufferPos = 0; i < len; i++) {\n    var hex = str.substr(i + 1, 2);\n    var chr = str.charAt(i);\n    if (chr === '=' && hex && /[\\da-fA-F]{2}/.test(hex)) {\n      buffer[bufferPos++] = parseInt(hex, 16);\n      i += 2;\n    } else {\n      buffer[bufferPos++] = chr.charCodeAt(0);\n    }\n  }\n  return (0, _charset.decode)(buffer, fromCharset);\n}\n\n/**\n * Encodes a string or an typed array of given charset into unicode\n * base64 string. Also adds line breaks\n *\n * @param {String|Uint8Array} data String or typed array to be base64 encoded\n * @param {String} Initial charset, e.g. 'binary'. Defaults to 'UTF-8'\n * @return {String} Base64 encoded string\n */\nfunction base64Encode(data) {\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var buf = typeof data !== 'string' && fromCharset === 'binary' ? data : (0, _charset.convert)(data, fromCharset);\n  var b64 = (0, _emailjsBase.encode)(buf);\n  return _addBase64SoftLinebreaks(b64);\n}\n\n/**\n * Decodes a base64 string of any charset into an unicode string\n *\n * @param {String} str Base64 encoded string\n * @param {String} [fromCharset='UTF-8'] Original charset of the base64 encoded string\n * @return {String} Decoded unicode string\n */\nfunction base64Decode(str, fromCharset) {\n  var buf = (0, _emailjsBase.decode)(str, _emailjsBase.OUTPUT_TYPED_ARRAY);\n  return fromCharset === 'binary' ? (0, _charset.arr2str)(buf) : (0, _charset.decode)(buf, fromCharset);\n}\n\n/**\n * Encodes a string or an Uint8Array into a quoted printable encoding\n * This is almost the same as mimeEncode, except line breaks will be changed\n * as well to ensure that the lines are never longer than allowed length\n *\n * @param {String|Uint8Array} data String or an Uint8Array to mime encode\n * @param {String} [fromCharset='UTF-8'] Original charset of the string\n * @return {String} Mime encoded string\n */\nfunction quotedPrintableEncode() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var mimeEncodedStr = mimeEncode(data, fromCharset).replace(/\\r?\\n|\\r/g, '\\r\\n') // fix line breaks, ensure <CR><LF>\n  .replace(/[\\t ]+$/gm, function (spaces) {\n    return spaces.replace(/ /g, '=20').replace(/\\t/g, '=09');\n  }); // replace spaces in the end of lines\n\n  return _addQPSoftLinebreaks(mimeEncodedStr); // add soft line breaks to ensure line lengths sjorter than 76 bytes\n}\n\n/**\n * Decodes a string from a quoted printable encoding. This is almost the\n * same as mimeDecode, except line breaks will be changed as well\n *\n * @param {String} str Mime encoded string to decode\n * @param {String} [fromCharset='UTF-8'] Original charset of the string\n * @return {String} Mime decoded string\n */\nfunction quotedPrintableDecode() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fromCharset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'UTF-8';\n  var rawString = str.replace(/[\\t ]+$/gm, '') // remove invalid whitespace from the end of lines\n  .replace(/=(?:\\r?\\n|$)/g, ''); // remove soft line breaks\n\n  return mimeDecode(rawString, fromCharset);\n}\n\n/**\n * Encodes a string or an Uint8Array to an UTF-8 MIME Word\n *   https://tools.ietf.org/html/rfc2047\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {String} Single or several mime words joined together\n */\nfunction mimeWordEncode(data) {\n  var mimeWordEncoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Q';\n  var fromCharset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'UTF-8';\n  var parts = [];\n  var str = typeof data === 'string' ? data : (0, _charset.decode)(data, fromCharset);\n  if (mimeWordEncoding === 'Q') {\n    var _str = typeof data === 'string' ? data : (0, _charset.decode)(data, fromCharset);\n    var encodedStr = (0, _ramda.pipe)(mimeEncode, qEncodeForbiddenHeaderChars)(_str);\n    parts = encodedStr.length < MAX_MIME_WORD_LENGTH ? [encodedStr] : _splitMimeEncodedString(encodedStr, MAX_MIME_WORD_LENGTH);\n  } else {\n    // Fits as much as possible into every line without breaking utf-8 multibyte characters' octets up across lines\n    var j = 0;\n    var i = 0;\n    while (i < str.length) {\n      if ((0, _charset.encode)(str.substring(j, i)).length > MAX_B64_MIME_WORD_BYTE_LENGTH) {\n        // we went one character too far, substring at the char before\n        parts.push(str.substring(j, i - 1));\n        j = i - 1;\n      } else {\n        i++;\n      }\n    }\n    // add the remainder of the string\n    str.substring(j) && parts.push(str.substring(j));\n    parts = parts.map(_charset.encode).map(_emailjsBase.encode);\n  }\n  var prefix = '=?UTF-8?' + mimeWordEncoding + '?';\n  var suffix = '?= ';\n  return parts.map(function (p) {\n    return prefix + p + suffix;\n  }).join('').trim();\n}\n\n/**\n * Q-Encodes remaining forbidden header chars\n *   https://tools.ietf.org/html/rfc2047#section-5\n */\nvar qEncodeForbiddenHeaderChars = function qEncodeForbiddenHeaderChars(str) {\n  var qEncode = function qEncode(chr) {\n    return chr === ' ' ? '_' : '=' + (chr.charCodeAt(0) < 0x10 ? '0' : '') + chr.charCodeAt(0).toString(16).toUpperCase();\n  };\n  return str.replace(/[^a-z0-9!*+\\-/=]/ig, qEncode);\n};\n\n/**\n * Finds word sequences with non ascii text and converts these to mime words\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {String} String with possible mime words\n */\nfunction mimeWordsEncode() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var mimeWordEncoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Q';\n  var fromCharset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'UTF-8';\n  var regex = /([^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*(?:\\s+[^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*\\s*)?)+(?=\\s|$)/g;\n  return (0, _charset.decode)((0, _charset.convert)(data, fromCharset)).replace(regex, function (match) {\n    return match.length ? mimeWordEncode(match, mimeWordEncoding, fromCharset) : '';\n  });\n}\n\n/**\n * Decode a complete mime word encoded string\n *\n * @param {String} str Mime word encoded string\n * @return {String} Decoded unicode string\n */\nfunction mimeWordDecode() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var match = str.match(/^=\\?([\\w_\\-*]+)\\?([QqBb])\\?([^?]*)\\?=$/i);\n  if (!match) return str;\n\n  // RFC2231 added language tag to the encoding\n  // see: https://tools.ietf.org/html/rfc2231#section-5\n  // this implementation silently ignores this tag\n  var fromCharset = match[1].split('*').shift();\n  var encoding = (match[2] || 'Q').toString().toUpperCase();\n  var rawString = (match[3] || '').replace(/_/g, ' ');\n  if (encoding === 'B') {\n    return base64Decode(rawString, fromCharset);\n  } else if (encoding === 'Q') {\n    return mimeDecode(rawString, fromCharset);\n  } else {\n    return str;\n  }\n}\n\n/**\n * Decode a string that might include one or several mime words\n *\n * @param {String} str String including some mime words that will be encoded\n * @return {String} Decoded unicode string\n */\nfunction mimeWordsDecode() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  str = str.toString().replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]*\\?=)/g, '$1');\n  // join bytes of multi-byte UTF-8\n  var prevEncoding = void 0;\n  str = str.replace(/(\\?=)?=\\?[uU][tT][fF]-8\\?([QqBb])\\?/g, function (match, endOfPrevWord, encoding) {\n    var result = endOfPrevWord && encoding === prevEncoding ? '' : match;\n    prevEncoding = encoding;\n    return result;\n  });\n  str = str.replace(/=\\?[\\w_\\-*]+\\?[QqBb]\\?[^?]*\\?=/g, function (mimeWord) {\n    return mimeWordDecode(mimeWord.replace(/\\s+/g, ''));\n  });\n  return str;\n}\n\n/**\n * Folds long lines, useful for folding header lines (afterSpace=false) and\n * flowed text (afterSpace=true)\n *\n * @param {String} str String to be folded\n * @param {Boolean} afterSpace If true, leave a space in th end of a line\n * @return {String} String with folded lines\n */\nfunction foldLines() {\n  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var afterSpace = arguments[1];\n  var pos = 0;\n  var len = str.length;\n  var result = '';\n  var line = void 0,\n    match = void 0;\n  while (pos < len) {\n    line = str.substr(pos, MAX_LINE_LENGTH);\n    if (line.length < MAX_LINE_LENGTH) {\n      result += line;\n      break;\n    }\n    if (match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/)) {\n      line = match[0];\n      result += line;\n      pos += line.length;\n      continue;\n    } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n      line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));\n    } else if (match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/)) {\n      line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));\n    }\n    result += line;\n    pos += line.length;\n    if (pos < len) {\n      result += '\\r\\n';\n    }\n  }\n  return result;\n}\n\n/**\n * Encodes and folds a header line for a MIME message header.\n * Shorthand for mimeWordsEncode + foldLines\n *\n * @param {String} key Key name, will not be encoded\n * @param {String|Uint8Array} value Value to be encoded\n * @param {String} [fromCharset='UTF-8'] Character set of the value\n * @return {String} encoded and folded header line\n */\nfunction headerLineEncode(key, value, fromCharset) {\n  var encodedValue = mimeWordsEncode(value, 'Q', fromCharset);\n  return foldLines(key + ': ' + encodedValue);\n}\n\n/**\n * The result is not mime word decoded, you need to do your own decoding based\n * on the rules for the specific header key\n *\n * @param {String} headerLine Single header line, might include linebreaks as well if folded\n * @return {Object} And object of {key, value}\n */\nfunction headerLineDecode() {\n  var headerLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var line = headerLine.toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, ' ').trim();\n  var match = line.match(/^\\s*([^:]+):(.*)$/);\n  return {\n    key: (match && match[1] || '').trim(),\n    value: (match && match[2] || '').trim()\n  };\n}\n\n/**\n * Parses a block of header lines. Does not decode mime words as every\n * header might have its own rules (eg. formatted email addresses and such)\n *\n * @param {String} headers Headers string\n * @return {Object} An object of headers, where header keys are object keys. NB! Several values with the same key make up an Array\n */\nfunction headerLinesDecode(headers) {\n  var lines = headers.split(/\\r?\\n|\\r/);\n  var headersObj = {};\n  for (var i = lines.length - 1; i >= 0; i--) {\n    if (i && lines[i].match(/^\\s/)) {\n      lines[i - 1] += '\\r\\n' + lines[i];\n      lines.splice(i, 1);\n    }\n  }\n  for (var _i = 0, len = lines.length; _i < len; _i++) {\n    var header = headerLineDecode(lines[_i]);\n    var key = header.key.toLowerCase();\n    var value = header.value;\n    if (!headersObj[key]) {\n      headersObj[key] = value;\n    } else {\n      headersObj[key] = [].concat(headersObj[key], value);\n    }\n  }\n  return headersObj;\n}\n\n/**\n * Parses a header value with key=value arguments into a structured\n * object.\n *\n *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n *   {\n *     'value': 'text/plain',\n *     'params': {\n *       'charset': 'UTF-8'\n *     }\n *   }\n *\n * @param {String} str Header value\n * @return {Object} Header value as a parsed structure\n */\nfunction parseHeaderValue(str) {\n  var response = {\n    value: false,\n    params: {}\n  };\n  var key = false;\n  var value = '';\n  var type = 'value';\n  var quote = false;\n  var escaped = false;\n  var chr = void 0;\n  for (var i = 0, len = str.length; i < len; i++) {\n    chr = str.charAt(i);\n    if (type === 'key') {\n      if (chr === '=') {\n        key = value.trim().toLowerCase();\n        type = 'value';\n        value = '';\n        continue;\n      }\n      value += chr;\n    } else {\n      if (escaped) {\n        value += chr;\n      } else if (chr === '\\\\') {\n        escaped = true;\n        continue;\n      } else if (quote && chr === quote) {\n        quote = false;\n      } else if (!quote && chr === '\"') {\n        quote = chr;\n      } else if (!quote && chr === ';') {\n        if (key === false) {\n          response.value = value.trim();\n        } else {\n          response.params[key] = value.trim();\n        }\n        type = 'key';\n        value = '';\n      } else {\n        value += chr;\n      }\n      escaped = false;\n    }\n  }\n  if (type === 'value') {\n    if (key === false) {\n      response.value = value.trim();\n    } else {\n      response.params[key] = value.trim();\n    }\n  } else if (value.trim()) {\n    response.params[value.trim().toLowerCase()] = '';\n  }\n\n  // handle parameter value continuations\n  // https://tools.ietf.org/html/rfc2231#section-3\n\n  // preprocess values\n  Object.keys(response.params).forEach(function (key) {\n    var actualKey, nr, match, value;\n    if (match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/)) {\n      actualKey = key.substr(0, match.index);\n      nr = Number(match[2] || match[3]) || 0;\n      if (!response.params[actualKey] || _typeof(response.params[actualKey]) !== 'object') {\n        response.params[actualKey] = {\n          charset: false,\n          values: []\n        };\n      }\n      value = response.params[key];\n      if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n        response.params[actualKey].charset = match[1] || 'iso-8859-1';\n        value = match[2];\n      }\n      response.params[actualKey].values[nr] = value;\n\n      // remove the old reference\n      delete response.params[key];\n    }\n  });\n\n  // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n  Object.keys(response.params).forEach(function (key) {\n    var value;\n    if (response.params[key] && Array.isArray(response.params[key].values)) {\n      value = response.params[key].values.map(function (val) {\n        return val || '';\n      }).join('');\n      if (response.params[key].charset) {\n        // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n        response.params[key] = '=?' + response.params[key].charset + '?Q?' + value.replace(/[=?_\\s]/g, function (s) {\n          // fix invalidly encoded chars\n          var c = s.charCodeAt(0).toString(16);\n          return s === ' ' ? '_' : '%' + (c.length < 2 ? '0' : '') + c;\n        }).replace(/%/g, '=') + '?='; // change from urlencoding to percent encoding\n      } else {\n        response.params[key] = value;\n      }\n    }\n  });\n  return response;\n}\n\n/**\n * Encodes a string or an Uint8Array to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n * Useful for splitting long parameter values.\n *\n * For example\n *      title=\"unicode string\"\n * becomes\n *     title*0*=\"utf-8''unicode\"\n *     title*1*=\"%20string\"\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {Number} [maxLength=50] Max length for generated chunks\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {Array} A list of encoded keys and headers\n */\nfunction continuationEncode(key, data, maxLength, fromCharset) {\n  var list = [];\n  var encodedStr = typeof data === 'string' ? data : (0, _charset.decode)(data, fromCharset);\n  var line;\n  maxLength = maxLength || 50;\n\n  // process ascii only text\n  if (/^[\\w.\\- ]*$/.test(data)) {\n    // check if conversion is even needed\n    if (encodedStr.length <= maxLength) {\n      return [{\n        key: key,\n        value: /[\\s\";=]/.test(encodedStr) ? '\"' + encodedStr + '\"' : encodedStr\n      }];\n    }\n    encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), function (str) {\n      list.push({\n        line: str\n      });\n      return '';\n    });\n    if (encodedStr) {\n      list.push({\n        line: encodedStr\n      });\n    }\n  } else {\n    // process text with unicode or special chars\n    var uriEncoded = encodeURIComponent('utf-8\\'\\'' + encodedStr);\n    var i = 0;\n    while (true) {\n      var len = maxLength;\n      // must not split hex encoded byte between lines\n      if (uriEncoded[i + maxLength - 1] === '%') {\n        len -= 1;\n      } else if (uriEncoded[i + maxLength - 2] === '%') {\n        len -= 2;\n      }\n      line = uriEncoded.substr(i, len);\n      if (!line) {\n        break;\n      }\n      list.push({\n        line: line,\n        encoded: true\n      });\n      i += line.length;\n    }\n  }\n  return list.map(function (item, i) {\n    return {\n      // encoded lines: {name}*{part}*\n      // unencoded lines: {name}*{part}\n      // if any line needs to be encoded then the first line (part==0) is always encoded\n      key: key + '*' + i + (item.encoded ? '*' : ''),\n      value: /[\\s\";=]/.test(item.line) ? '\"' + item.line + '\"' : item.line\n    };\n  });\n}\n\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {String} str Mime encoded string to be split up\n * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {Array} Split string\n */\nfunction _splitMimeEncodedString(str) {\n  var maxlen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;\n  var minWordLength = 12; // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n  var maxWordLength = Math.max(maxlen, minWordLength);\n  var lines = [];\n  while (str.length) {\n    var curLine = str.substr(0, maxWordLength);\n    var match = curLine.match(/=[0-9A-F]?$/i); // skip incomplete escaped char\n    if (match) {\n      curLine = curLine.substr(0, match.index);\n    }\n    var done = false;\n    while (!done) {\n      var chr = void 0;\n      done = true;\n      var _match = str.substr(curLine.length).match(/^=([0-9A-F]{2})/i); // check if not middle of a unicode char sequence\n      if (_match) {\n        chr = parseInt(_match[1], 16);\n        // invalid sequence, move one char back anc recheck\n        if (chr < 0xC2 && chr > 0x7F) {\n          curLine = curLine.substr(0, curLine.length - 3);\n          done = false;\n        }\n      }\n    }\n    if (curLine.length) {\n      lines.push(curLine);\n    }\n    str = str.substr(curLine.length);\n  }\n  return lines;\n}\nfunction _addBase64SoftLinebreaks() {\n  var base64EncodedStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return base64EncodedStr.trim().replace(new RegExp('.{' + MAX_LINE_LENGTH + '}', 'g'), '$&\\r\\n').trim();\n}\n\n/**\n * Adds soft line breaks(the ones that will be stripped out when decoding QP)\n *\n * @param {String} qpEncodedStr String in Quoted-Printable encoding\n * @return {String} String with forced line breaks\n */\nfunction _addQPSoftLinebreaks() {\n  var qpEncodedStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var pos = 0;\n  var len = qpEncodedStr.length;\n  var lineMargin = Math.floor(MAX_LINE_LENGTH / 3);\n  var result = '';\n  var match = void 0,\n    line = void 0;\n\n  // insert soft linebreaks where needed\n  while (pos < len) {\n    line = qpEncodedStr.substr(pos, MAX_LINE_LENGTH);\n    if (match = line.match(/\\r\\n/)) {\n      line = line.substr(0, match.index + match[0].length);\n      result += line;\n      pos += line.length;\n      continue;\n    }\n    if (line.substr(-1) === '\\n') {\n      // nothing to change here\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (match = line.substr(-lineMargin).match(/\\n.*?$/)) {\n      // truncate to nearest line break\n      line = line.substr(0, line.length - (match[0].length - 1));\n      result += line;\n      pos += line.length;\n      continue;\n    } else if (line.length > MAX_LINE_LENGTH - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t.,!?][^ \\t.,!?]*$/))) {\n      // truncate to nearest space\n      line = line.substr(0, line.length - (match[0].length - 1));\n    } else if (line.substr(-1) === '\\r') {\n      line = line.substr(0, line.length - 1);\n    } else {\n      if (line.match(/=[\\da-f]{0,2}$/i)) {\n        // push incomplete encoding sequences to the next line\n        if (match = line.match(/=[\\da-f]{0,1}$/i)) {\n          line = line.substr(0, line.length - match[0].length);\n        }\n\n        // ensure that utf-8 sequences are not split\n        while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/=[\\da-f]{2}$/ig))) {\n          var code = parseInt(match[0].substr(1, 2), 16);\n          if (code < 128) {\n            break;\n          }\n          line = line.substr(0, line.length - 3);\n          if (code >= 0xC0) {\n            break;\n          }\n        }\n      }\n    }\n    if (pos + line.length < len && line.substr(-1) !== '\\n') {\n      if (line.length === MAX_LINE_LENGTH && line.match(/=[\\da-f]{2}$/i)) {\n        line = line.substr(0, line.length - 3);\n      } else if (line.length === MAX_LINE_LENGTH) {\n        line = line.substr(0, line.length - 1);\n      }\n      pos += line.length;\n      line += '=\\r\\n';\n    } else {\n      pos += line.length;\n    }\n    result += line;\n  }\n  return result;\n}\nexports.decode = _charset.decode;\nexports.encode = _charset.encode;\nexports.convert = _charset.convert;","map":{"version":3,"names":["mimeEncode","mimeDecode","base64Encode","base64Decode","quotedPrintableEncode","quotedPrintableDecode","mimeWordEncode","mimeWordsEncode","mimeWordDecode","mimeWordsDecode","foldLines","headerLineEncode","headerLineDecode","headerLinesDecode","parseHeaderValue","continuationEncode","_emailjsBase","require","_charset","_ramda","MAX_LINE_LENGTH","MAX_MIME_WORD_LENGTH","MAX_B64_MIME_WORD_BYTE_LENGTH","data","arguments","length","undefined","fromCharset","buffer","convert","reduce","aggregate","ord","index","_checkRanges","String","fromCharCode","toString","toUpperCase","nr","ranges","val","range","str","encodedBytesCount","match","Uint8Array","i","len","bufferPos","hex","substr","chr","charAt","test","parseInt","charCodeAt","decode","buf","b64","encode","_addBase64SoftLinebreaks","OUTPUT_TYPED_ARRAY","arr2str","mimeEncodedStr","replace","spaces","_addQPSoftLinebreaks","rawString","mimeWordEncoding","parts","_str","encodedStr","pipe","qEncodeForbiddenHeaderChars","_splitMimeEncodedString","j","substring","push","map","prefix","suffix","p","join","trim","qEncode","regex","split","shift","encoding","prevEncoding","endOfPrevWord","result","mimeWord","afterSpace","pos","line","key","value","encodedValue","headerLine","headers","lines","headersObj","splice","_i","header","toLowerCase","concat","response","params","type","quote","escaped","Object","keys","forEach","actualKey","Number","_typeof","charset","values","Array","isArray","s","c","maxLength","list","RegExp","uriEncoded","encodeURIComponent","encoded","item","maxlen","minWordLength","maxWordLength","Math","max","curLine","done","_match","base64EncodedStr","qpEncodedStr","lineMargin","floor","code"],"sources":["/home/vaslyb/Desktop/witheflow/annotator/src/node_modules/emailjs-mime-codec/src/mimecodec.js"],"sourcesContent":["import { encode as encodeBase64, decode as decodeBase64, OUTPUT_TYPED_ARRAY } from 'emailjs-base64'\nimport { encode, decode, convert, arr2str } from './charset'\nimport { pipe } from 'ramda'\n\n// Lines can't be longer than 76 + <CR><LF> = 78 bytes\n// http://tools.ietf.org/html/rfc2045#section-6.7\nconst MAX_LINE_LENGTH = 76\nconst MAX_MIME_WORD_LENGTH = 52\nconst MAX_B64_MIME_WORD_BYTE_LENGTH = 39\n\n/**\n * Encodes all non printable and non ascii bytes to =XX form, where XX is the\n * byte value in hex. This function does not convert linebreaks etc. it\n * only escapes character sequences\n *\n * @param {String|Uint8Array} data Either a string or an Uint8Array\n * @param {String} [fromCharset='UTF-8'] Source encoding\n * @return {String} Mime encoded string\n */\nexport function mimeEncode (data = '', fromCharset = 'UTF-8') {\n  const buffer = convert(data, fromCharset)\n  return buffer.reduce((aggregate, ord, index) =>\n    _checkRanges(ord) && !((ord === 0x20 || ord === 0x09) && (index === buffer.length - 1 || buffer[index + 1] === 0x0a || buffer[index + 1] === 0x0d))\n      ? aggregate + String.fromCharCode(ord) // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n      : aggregate + '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase(), '')\n\n  function _checkRanges (nr) {\n    const ranges = [ // https://tools.ietf.org/html/rfc2045#section-6.7\n      [0x09], // <TAB>\n      [0x0A], // <LF>\n      [0x0D], // <CR>\n      [0x20, 0x3C], // <SP>!\"#$%&'()*+,-./0123456789:;\n      [0x3E, 0x7E] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n    ]\n    return ranges.reduce((val, range) => val || (range.length === 1 && nr === range[0]) || (range.length === 2 && nr >= range[0] && nr <= range[1]), false)\n  }\n}\n\n/**\n * Decodes mime encoded string to an unicode string\n *\n * @param {String} str Mime encoded string\n * @param {String} [fromCharset='UTF-8'] Source encoding\n * @return {String} Decoded unicode string\n */\nexport function mimeDecode (str = '', fromCharset = 'UTF-8') {\n  const encodedBytesCount = (str.match(/=[\\da-fA-F]{2}/g) || []).length\n  let buffer = new Uint8Array(str.length - encodedBytesCount * 2)\n\n  for (var i = 0, len = str.length, bufferPos = 0; i < len; i++) {\n    let hex = str.substr(i + 1, 2)\n    const chr = str.charAt(i)\n    if (chr === '=' && hex && /[\\da-fA-F]{2}/.test(hex)) {\n      buffer[bufferPos++] = parseInt(hex, 16)\n      i += 2\n    } else {\n      buffer[bufferPos++] = chr.charCodeAt(0)\n    }\n  }\n\n  return decode(buffer, fromCharset)\n}\n\n/**\n * Encodes a string or an typed array of given charset into unicode\n * base64 string. Also adds line breaks\n *\n * @param {String|Uint8Array} data String or typed array to be base64 encoded\n * @param {String} Initial charset, e.g. 'binary'. Defaults to 'UTF-8'\n * @return {String} Base64 encoded string\n */\nexport function base64Encode (data, fromCharset = 'UTF-8') {\n  const buf = (typeof data !== 'string' && fromCharset === 'binary') ? data : convert(data, fromCharset)\n  const b64 = encodeBase64(buf)\n  return _addBase64SoftLinebreaks(b64)\n}\n\n/**\n * Decodes a base64 string of any charset into an unicode string\n *\n * @param {String} str Base64 encoded string\n * @param {String} [fromCharset='UTF-8'] Original charset of the base64 encoded string\n * @return {String} Decoded unicode string\n */\nexport function base64Decode (str, fromCharset) {\n  const buf = decodeBase64(str, OUTPUT_TYPED_ARRAY)\n  return fromCharset === 'binary' ? arr2str(buf) : decode(buf, fromCharset)\n}\n\n/**\n * Encodes a string or an Uint8Array into a quoted printable encoding\n * This is almost the same as mimeEncode, except line breaks will be changed\n * as well to ensure that the lines are never longer than allowed length\n *\n * @param {String|Uint8Array} data String or an Uint8Array to mime encode\n * @param {String} [fromCharset='UTF-8'] Original charset of the string\n * @return {String} Mime encoded string\n */\nexport function quotedPrintableEncode (data = '', fromCharset = 'UTF-8') {\n  const mimeEncodedStr = mimeEncode(data, fromCharset)\n    .replace(/\\r?\\n|\\r/g, '\\r\\n') // fix line breaks, ensure <CR><LF>\n    .replace(/[\\t ]+$/gm, spaces => spaces.replace(/ /g, '=20').replace(/\\t/g, '=09')) // replace spaces in the end of lines\n\n  return _addQPSoftLinebreaks(mimeEncodedStr) // add soft line breaks to ensure line lengths sjorter than 76 bytes\n}\n\n/**\n * Decodes a string from a quoted printable encoding. This is almost the\n * same as mimeDecode, except line breaks will be changed as well\n *\n * @param {String} str Mime encoded string to decode\n * @param {String} [fromCharset='UTF-8'] Original charset of the string\n * @return {String} Mime decoded string\n */\nexport function quotedPrintableDecode (str = '', fromCharset = 'UTF-8') {\n  const rawString = str\n    .replace(/[\\t ]+$/gm, '') // remove invalid whitespace from the end of lines\n    .replace(/=(?:\\r?\\n|$)/g, '') // remove soft line breaks\n\n  return mimeDecode(rawString, fromCharset)\n}\n\n/**\n * Encodes a string or an Uint8Array to an UTF-8 MIME Word\n *   https://tools.ietf.org/html/rfc2047\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {String} Single or several mime words joined together\n */\nexport function mimeWordEncode (data, mimeWordEncoding = 'Q', fromCharset = 'UTF-8') {\n  let parts = []\n  const str = (typeof data === 'string') ? data : decode(data, fromCharset)\n\n  if (mimeWordEncoding === 'Q') {\n    const str = (typeof data === 'string') ? data : decode(data, fromCharset)\n    let encodedStr = pipe(mimeEncode, qEncodeForbiddenHeaderChars)(str)\n    parts = encodedStr.length < MAX_MIME_WORD_LENGTH ? [encodedStr] : _splitMimeEncodedString(encodedStr, MAX_MIME_WORD_LENGTH)\n  } else {\n    // Fits as much as possible into every line without breaking utf-8 multibyte characters' octets up across lines\n    let j = 0\n    let i = 0\n    while (i < str.length) {\n      if (encode(str.substring(j, i)).length > MAX_B64_MIME_WORD_BYTE_LENGTH) {\n        // we went one character too far, substring at the char before\n        parts.push(str.substring(j, i - 1))\n        j = i - 1\n      } else {\n        i++\n      }\n    }\n    // add the remainder of the string\n    str.substring(j) && parts.push(str.substring(j))\n    parts = parts.map(encode).map(encodeBase64)\n  }\n\n  const prefix = '=?UTF-8?' + mimeWordEncoding + '?'\n  const suffix = '?= '\n  return parts.map(p => prefix + p + suffix).join('').trim()\n}\n\n/**\n * Q-Encodes remaining forbidden header chars\n *   https://tools.ietf.org/html/rfc2047#section-5\n */\nconst qEncodeForbiddenHeaderChars = function (str) {\n  const qEncode = chr => chr === ' ' ? '_' : ('=' + (chr.charCodeAt(0) < 0x10 ? '0' : '') + chr.charCodeAt(0).toString(16).toUpperCase())\n  return str.replace(/[^a-z0-9!*+\\-/=]/ig, qEncode)\n}\n\n/**\n * Finds word sequences with non ascii text and converts these to mime words\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {String} String with possible mime words\n */\nexport function mimeWordsEncode (data = '', mimeWordEncoding = 'Q', fromCharset = 'UTF-8') {\n  const regex = /([^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*(?:\\s+[^\\s\\u0080-\\uFFFF]*[\\u0080-\\uFFFF]+[^\\s\\u0080-\\uFFFF]*\\s*)?)+(?=\\s|$)/g\n  return decode(convert(data, fromCharset)).replace(regex, match => match.length ? mimeWordEncode(match, mimeWordEncoding, fromCharset) : '')\n}\n\n/**\n * Decode a complete mime word encoded string\n *\n * @param {String} str Mime word encoded string\n * @return {String} Decoded unicode string\n */\nexport function mimeWordDecode (str = '') {\n  const match = str.match(/^=\\?([\\w_\\-*]+)\\?([QqBb])\\?([^?]*)\\?=$/i)\n  if (!match) return str\n\n  // RFC2231 added language tag to the encoding\n  // see: https://tools.ietf.org/html/rfc2231#section-5\n  // this implementation silently ignores this tag\n  const fromCharset = match[1].split('*').shift()\n  const encoding = (match[2] || 'Q').toString().toUpperCase()\n  const rawString = (match[3] || '').replace(/_/g, ' ')\n\n  if (encoding === 'B') {\n    return base64Decode(rawString, fromCharset)\n  } else if (encoding === 'Q') {\n    return mimeDecode(rawString, fromCharset)\n  } else {\n    return str\n  }\n}\n\n/**\n * Decode a string that might include one or several mime words\n *\n * @param {String} str String including some mime words that will be encoded\n * @return {String} Decoded unicode string\n */\nexport function mimeWordsDecode (str = '') {\n  str = str.toString().replace(/(=\\?[^?]+\\?[QqBb]\\?[^?]+\\?=)\\s+(?==\\?[^?]+\\?[QqBb]\\?[^?]*\\?=)/g, '$1')\n  // join bytes of multi-byte UTF-8\n  let prevEncoding\n  str = str.replace(/(\\?=)?=\\?[uU][tT][fF]-8\\?([QqBb])\\?/g, (match, endOfPrevWord, encoding) => {\n    const result = (endOfPrevWord && encoding === prevEncoding) ? '' : match\n    prevEncoding = encoding\n    return result\n  })\n  str = str.replace(/=\\?[\\w_\\-*]+\\?[QqBb]\\?[^?]*\\?=/g, mimeWord => mimeWordDecode(mimeWord.replace(/\\s+/g, '')))\n\n  return str\n}\n\n/**\n * Folds long lines, useful for folding header lines (afterSpace=false) and\n * flowed text (afterSpace=true)\n *\n * @param {String} str String to be folded\n * @param {Boolean} afterSpace If true, leave a space in th end of a line\n * @return {String} String with folded lines\n */\nexport function foldLines (str = '', afterSpace) {\n  let pos = 0\n  const len = str.length\n  let result = ''\n  let line, match\n\n  while (pos < len) {\n    line = str.substr(pos, MAX_LINE_LENGTH)\n    if (line.length < MAX_LINE_LENGTH) {\n      result += line\n      break\n    }\n    if ((match = line.match(/^[^\\n\\r]*(\\r?\\n|\\r)/))) {\n      line = match[0]\n      result += line\n      pos += line.length\n      continue\n    } else if ((match = line.match(/(\\s+)[^\\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {\n      line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)))\n    } else if ((match = str.substr(pos + line.length).match(/^[^\\s]+(\\s*)/))) {\n      line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0))\n    }\n\n    result += line\n    pos += line.length\n    if (pos < len) {\n      result += '\\r\\n'\n    }\n  }\n\n  return result\n}\n\n/**\n * Encodes and folds a header line for a MIME message header.\n * Shorthand for mimeWordsEncode + foldLines\n *\n * @param {String} key Key name, will not be encoded\n * @param {String|Uint8Array} value Value to be encoded\n * @param {String} [fromCharset='UTF-8'] Character set of the value\n * @return {String} encoded and folded header line\n */\nexport function headerLineEncode (key, value, fromCharset) {\n  var encodedValue = mimeWordsEncode(value, 'Q', fromCharset)\n  return foldLines(key + ': ' + encodedValue)\n}\n\n/**\n * The result is not mime word decoded, you need to do your own decoding based\n * on the rules for the specific header key\n *\n * @param {String} headerLine Single header line, might include linebreaks as well if folded\n * @return {Object} And object of {key, value}\n */\nexport function headerLineDecode (headerLine = '') {\n  const line = headerLine.toString().replace(/(?:\\r?\\n|\\r)[ \\t]*/g, ' ').trim()\n  const match = line.match(/^\\s*([^:]+):(.*)$/)\n\n  return {\n    key: ((match && match[1]) || '').trim(),\n    value: ((match && match[2]) || '').trim()\n  }\n}\n\n/**\n * Parses a block of header lines. Does not decode mime words as every\n * header might have its own rules (eg. formatted email addresses and such)\n *\n * @param {String} headers Headers string\n * @return {Object} An object of headers, where header keys are object keys. NB! Several values with the same key make up an Array\n */\nexport function headerLinesDecode (headers) {\n  const lines = headers.split(/\\r?\\n|\\r/)\n  const headersObj = {}\n\n  for (let i = lines.length - 1; i >= 0; i--) {\n    if (i && lines[i].match(/^\\s/)) {\n      lines[i - 1] += '\\r\\n' + lines[i]\n      lines.splice(i, 1)\n    }\n  }\n\n  for (let i = 0, len = lines.length; i < len; i++) {\n    const header = headerLineDecode(lines[i])\n    const key = header.key.toLowerCase()\n    const value = header.value\n\n    if (!headersObj[key]) {\n      headersObj[key] = value\n    } else {\n      headersObj[key] = [].concat(headersObj[key], value)\n    }\n  }\n\n  return headersObj\n}\n\n/**\n * Parses a header value with key=value arguments into a structured\n * object.\n *\n *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->\n *   {\n *     'value': 'text/plain',\n *     'params': {\n *       'charset': 'UTF-8'\n *     }\n *   }\n *\n * @param {String} str Header value\n * @return {Object} Header value as a parsed structure\n */\nexport function parseHeaderValue (str) {\n  let response = {\n    value: false,\n    params: {}\n  }\n  let key = false\n  let value = ''\n  let type = 'value'\n  let quote = false\n  let escaped = false\n  let chr\n\n  for (let i = 0, len = str.length; i < len; i++) {\n    chr = str.charAt(i)\n    if (type === 'key') {\n      if (chr === '=') {\n        key = value.trim().toLowerCase()\n        type = 'value'\n        value = ''\n        continue\n      }\n      value += chr\n    } else {\n      if (escaped) {\n        value += chr\n      } else if (chr === '\\\\') {\n        escaped = true\n        continue\n      } else if (quote && chr === quote) {\n        quote = false\n      } else if (!quote && chr === '\"') {\n        quote = chr\n      } else if (!quote && chr === ';') {\n        if (key === false) {\n          response.value = value.trim()\n        } else {\n          response.params[key] = value.trim()\n        }\n        type = 'key'\n        value = ''\n      } else {\n        value += chr\n      }\n      escaped = false\n    }\n  }\n\n  if (type === 'value') {\n    if (key === false) {\n      response.value = value.trim()\n    } else {\n      response.params[key] = value.trim()\n    }\n  } else if (value.trim()) {\n    response.params[value.trim().toLowerCase()] = ''\n  }\n\n  // handle parameter value continuations\n  // https://tools.ietf.org/html/rfc2231#section-3\n\n  // preprocess values\n  Object.keys(response.params).forEach(function (key) {\n    var actualKey, nr, match, value\n    if ((match = key.match(/(\\*(\\d+)|\\*(\\d+)\\*|\\*)$/))) {\n      actualKey = key.substr(0, match.index)\n      nr = Number(match[2] || match[3]) || 0\n\n      if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {\n        response.params[actualKey] = {\n          charset: false,\n          values: []\n        }\n      }\n\n      value = response.params[key]\n\n      if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {\n        response.params[actualKey].charset = match[1] || 'iso-8859-1'\n        value = match[2]\n      }\n\n      response.params[actualKey].values[nr] = value\n\n      // remove the old reference\n      delete response.params[key]\n    }\n  })\n\n  // concatenate split rfc2231 strings and convert encoded strings to mime encoded words\n  Object.keys(response.params).forEach(function (key) {\n    var value\n    if (response.params[key] && Array.isArray(response.params[key].values)) {\n      value = response.params[key].values.map(function (val) {\n        return val || ''\n      }).join('')\n\n      if (response.params[key].charset) {\n        // convert \"%AB\" to \"=?charset?Q?=AB?=\"\n        response.params[key] = '=?' + response.params[key].charset + '?Q?' + value\n          .replace(/[=?_\\s]/g, function (s) {\n            // fix invalidly encoded chars\n            var c = s.charCodeAt(0).toString(16)\n            return s === ' ' ? '_' : '%' + (c.length < 2 ? '0' : '') + c\n          })\n          .replace(/%/g, '=') + '?=' // change from urlencoding to percent encoding\n      } else {\n        response.params[key] = value\n      }\n    }\n  })\n\n  return response\n}\n\n/**\n * Encodes a string or an Uint8Array to an UTF-8 Parameter Value Continuation encoding (rfc2231)\n * Useful for splitting long parameter values.\n *\n * For example\n *      title=\"unicode string\"\n * becomes\n *     title*0*=\"utf-8''unicode\"\n *     title*1*=\"%20string\"\n *\n * @param {String|Uint8Array} data String to be encoded\n * @param {Number} [maxLength=50] Max length for generated chunks\n * @param {String} [fromCharset='UTF-8'] Source sharacter set\n * @return {Array} A list of encoded keys and headers\n */\nexport function continuationEncode (key, data, maxLength, fromCharset) {\n  const list = []\n  var encodedStr = typeof data === 'string' ? data : decode(data, fromCharset)\n  var line\n\n  maxLength = maxLength || 50\n\n  // process ascii only text\n  if (/^[\\w.\\- ]*$/.test(data)) {\n    // check if conversion is even needed\n    if (encodedStr.length <= maxLength) {\n      return [{\n        key: key,\n        value: /[\\s\";=]/.test(encodedStr) ? '\"' + encodedStr + '\"' : encodedStr\n      }]\n    }\n\n    encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), function (str) {\n      list.push({\n        line: str\n      })\n      return ''\n    })\n\n    if (encodedStr) {\n      list.push({\n        line: encodedStr\n      })\n    }\n  } else {\n    // process text with unicode or special chars\n    const uriEncoded = encodeURIComponent('utf-8\\'\\'' + encodedStr)\n    let i = 0\n    while (true) {\n      let len = maxLength\n      // must not split hex encoded byte between lines\n      if (uriEncoded[i + maxLength - 1] === '%') {\n        len -= 1\n      } else if (uriEncoded[i + maxLength - 2] === '%') {\n        len -= 2\n      }\n      line = uriEncoded.substr(i, len)\n      if (!line) {\n        break\n      }\n      list.push({\n        line: line,\n        encoded: true\n      })\n      i += line.length\n    }\n  }\n\n  return list.map(function (item, i) {\n    return {\n      // encoded lines: {name}*{part}*\n      // unencoded lines: {name}*{part}\n      // if any line needs to be encoded then the first line (part==0) is always encoded\n      key: key + '*' + i + (item.encoded ? '*' : ''),\n      value: /[\\s\";=]/.test(item.line) ? '\"' + item.line + '\"' : item.line\n    }\n  })\n}\n\n/**\n * Splits a mime encoded string. Needed for dividing mime words into smaller chunks\n *\n * @param {String} str Mime encoded string to be split up\n * @param {Number} maxlen Maximum length of characters for one part (minimum 12)\n * @return {Array} Split string\n */\nfunction _splitMimeEncodedString (str, maxlen = 12) {\n  const minWordLength = 12 // require at least 12 symbols to fit possible 4 octet UTF-8 sequences\n  const maxWordLength = Math.max(maxlen, minWordLength)\n  const lines = []\n\n  while (str.length) {\n    let curLine = str.substr(0, maxWordLength)\n\n    const match = curLine.match(/=[0-9A-F]?$/i) // skip incomplete escaped char\n    if (match) {\n      curLine = curLine.substr(0, match.index)\n    }\n\n    let done = false\n    while (!done) {\n      let chr\n      done = true\n      const match = str.substr(curLine.length).match(/^=([0-9A-F]{2})/i) // check if not middle of a unicode char sequence\n      if (match) {\n        chr = parseInt(match[1], 16)\n        // invalid sequence, move one char back anc recheck\n        if (chr < 0xC2 && chr > 0x7F) {\n          curLine = curLine.substr(0, curLine.length - 3)\n          done = false\n        }\n      }\n    }\n\n    if (curLine.length) {\n      lines.push(curLine)\n    }\n    str = str.substr(curLine.length)\n  }\n\n  return lines\n}\n\nfunction _addBase64SoftLinebreaks (base64EncodedStr = '') {\n  return base64EncodedStr.trim().replace(new RegExp('.{' + MAX_LINE_LENGTH + '}', 'g'), '$&\\r\\n').trim()\n}\n\n/**\n * Adds soft line breaks(the ones that will be stripped out when decoding QP)\n *\n * @param {String} qpEncodedStr String in Quoted-Printable encoding\n * @return {String} String with forced line breaks\n */\nfunction _addQPSoftLinebreaks (qpEncodedStr = '') {\n  let pos = 0\n  const len = qpEncodedStr.length\n  const lineMargin = Math.floor(MAX_LINE_LENGTH / 3)\n  let result = ''\n  let match, line\n\n  // insert soft linebreaks where needed\n  while (pos < len) {\n    line = qpEncodedStr.substr(pos, MAX_LINE_LENGTH)\n    if ((match = line.match(/\\r\\n/))) {\n      line = line.substr(0, match.index + match[0].length)\n      result += line\n      pos += line.length\n      continue\n    }\n\n    if (line.substr(-1) === '\\n') {\n      // nothing to change here\n      result += line\n      pos += line.length\n      continue\n    } else if ((match = line.substr(-lineMargin).match(/\\n.*?$/))) {\n      // truncate to nearest line break\n      line = line.substr(0, line.length - (match[0].length - 1))\n      result += line\n      pos += line.length\n      continue\n    } else if (line.length > MAX_LINE_LENGTH - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t.,!?][^ \\t.,!?]*$/))) {\n      // truncate to nearest space\n      line = line.substr(0, line.length - (match[0].length - 1))\n    } else if (line.substr(-1) === '\\r') {\n      line = line.substr(0, line.length - 1)\n    } else {\n      if (line.match(/=[\\da-f]{0,2}$/i)) {\n        // push incomplete encoding sequences to the next line\n        if ((match = line.match(/=[\\da-f]{0,1}$/i))) {\n          line = line.substr(0, line.length - match[0].length)\n        }\n\n        // ensure that utf-8 sequences are not split\n        while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/=[\\da-f]{2}$/ig))) {\n          const code = parseInt(match[0].substr(1, 2), 16)\n          if (code < 128) {\n            break\n          }\n\n          line = line.substr(0, line.length - 3)\n\n          if (code >= 0xC0) {\n            break\n          }\n        }\n      }\n    }\n\n    if (pos + line.length < len && line.substr(-1) !== '\\n') {\n      if (line.length === MAX_LINE_LENGTH && line.match(/=[\\da-f]{2}$/i)) {\n        line = line.substr(0, line.length - 3)\n      } else if (line.length === MAX_LINE_LENGTH) {\n        line = line.substr(0, line.length - 1)\n      }\n      pos += line.length\n      line += '=\\r\\n'\n    } else {\n      pos += line.length\n    }\n\n    result += line\n  }\n\n  return result\n}\n\nexport { decode, encode, convert }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}