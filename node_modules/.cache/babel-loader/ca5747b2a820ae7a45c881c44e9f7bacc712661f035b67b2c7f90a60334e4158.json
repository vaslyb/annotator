{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MimeNode = exports.NodeCounter = undefined;\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nexports.default = parse;\nvar _ramda = require('ramda');\nvar _timezones = require('./timezones');\nvar _timezones2 = _interopRequireDefault(_timezones);\nvar _emailjsMimeCodec = require('emailjs-mime-codec');\nvar _textEncoding = require('text-encoding');\nvar _emailjsAddressparser = require('emailjs-addressparser');\nvar _emailjsAddressparser2 = _interopRequireDefault(_emailjsAddressparser);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/*\n * Counts MIME nodes to prevent memory exhaustion attacks (CWE-400)\n * see: https://snyk.io/vuln/npm:emailjs-mime-parser:20180625\n */\nvar MAXIMUM_NUMBER_OF_MIME_NODES = 999;\nvar NodeCounter = exports.NodeCounter = function () {\n  function NodeCounter() {\n    _classCallCheck(this, NodeCounter);\n    this.count = 0;\n  }\n  _createClass(NodeCounter, [{\n    key: 'bump',\n    value: function bump() {\n      if (++this.count > MAXIMUM_NUMBER_OF_MIME_NODES) {\n        throw new Error('Maximum number of MIME nodes exceeded!');\n      }\n    }\n  }]);\n  return NodeCounter;\n}();\nfunction parse(chunk) {\n  var root = new MimeNode(new NodeCounter());\n  var lines = ((typeof chunk === 'undefined' ? 'undefined' : _typeof(chunk)) === 'object' ? String.fromCharCode.apply(null, chunk) : chunk).split(/\\r?\\n/g);\n  lines.forEach(function (line) {\n    return root.writeLine(line);\n  });\n  root.finalize();\n  return root;\n}\nvar MimeNode = exports.MimeNode = function () {\n  function MimeNode() {\n    var nodeCounter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new NodeCounter();\n    _classCallCheck(this, MimeNode);\n    this.nodeCounter = nodeCounter;\n    this.nodeCounter.bump();\n    this.header = []; // An array of unfolded header lines\n    this.headers = {}; // An object that holds header key=value pairs\n    this.bodystructure = '';\n    this.childNodes = []; // If this is a multipart or message/rfc822 mime part, the value will be converted to array and hold all child nodes for this node\n    this.raw = ''; // Stores the raw content of this node\n\n    this._state = 'HEADER'; // Current state, always starts out with HEADER\n    this._bodyBuffer = ''; // Body buffer\n    this._lineCount = 0; // Line counter bor the body part\n    this._currentChild = false; // Active child node (if available)\n    this._lineRemainder = ''; // Remainder string when dealing with base64 and qp values\n    this._isMultipart = false; // Indicates if this is a multipart node\n    this._multipartBoundary = false; // Stores boundary value for current multipart node\n    this._isRfc822 = false; // Indicates if this is a message/rfc822 node\n  }\n  _createClass(MimeNode, [{\n    key: 'writeLine',\n    value: function writeLine(line) {\n      this.raw += (this.raw ? '\\n' : '') + line;\n      if (this._state === 'HEADER') {\n        this._processHeaderLine(line);\n      } else if (this._state === 'BODY') {\n        this._processBodyLine(line);\n      }\n    }\n  }, {\n    key: 'finalize',\n    value: function finalize() {\n      var _this = this;\n      if (this._isRfc822) {\n        this._currentChild.finalize();\n      } else {\n        this._emitBody();\n      }\n      this.bodystructure = this.childNodes.reduce(function (agg, child) {\n        return agg + '--' + _this._multipartBoundary + '\\n' + child.bodystructure;\n      }, this.header.join('\\n') + '\\n\\n') + (this._multipartBoundary ? '--' + this._multipartBoundary + '--\\n' : '');\n    }\n  }, {\n    key: '_decodeBodyBuffer',\n    value: function _decodeBodyBuffer() {\n      switch (this.contentTransferEncoding.value) {\n        case 'base64':\n          this._bodyBuffer = (0, _emailjsMimeCodec.base64Decode)(this._bodyBuffer, this.charset);\n          break;\n        case 'quoted-printable':\n          {\n            this._bodyBuffer = this._bodyBuffer.replace(/=(\\r?\\n|$)/g, '').replace(/=([a-f0-9]{2})/ig, function (m, code) {\n              return String.fromCharCode(parseInt(code, 16));\n            });\n            break;\n          }\n      }\n    }\n\n    /**\n     * Processes a line in the HEADER state. It the line is empty, change state to BODY\n     *\n     * @param {String} line Entire input line as 'binary' string\n     */\n  }, {\n    key: '_processHeaderLine',\n    value: function _processHeaderLine(line) {\n      if (!line) {\n        this._parseHeaders();\n        this.bodystructure += this.header.join('\\n') + '\\n\\n';\n        this._state = 'BODY';\n        return;\n      }\n      if (line.match(/^\\s/) && this.header.length) {\n        this.header[this.header.length - 1] += '\\n' + line;\n      } else {\n        this.header.push(line);\n      }\n    }\n\n    /**\n     * Joins folded header lines and calls Content-Type and Transfer-Encoding processors\n     */\n  }, {\n    key: '_parseHeaders',\n    value: function _parseHeaders() {\n      for (var hasBinary = false, i = 0, len = this.header.length; i < len; i++) {\n        var value = this.header[i].split(':');\n        var key = (value.shift() || '').trim().toLowerCase();\n        value = (value.join(':') || '').replace(/\\n/g, '').trim();\n        if (value.match(/[\\u0080-\\uFFFF]/)) {\n          if (!this.charset) {\n            hasBinary = true;\n          }\n          // use default charset at first and if the actual charset is resolved, the conversion is re-run\n          value = (0, _emailjsMimeCodec.decode)((0, _emailjsMimeCodec.convert)(str2arr(value), this.charset || 'iso-8859-1'));\n        }\n        this.headers[key] = (this.headers[key] || []).concat([this._parseHeaderValue(key, value)]);\n        if (!this.charset && key === 'content-type') {\n          this.charset = this.headers[key][this.headers[key].length - 1].params.charset;\n        }\n        if (hasBinary && this.charset) {\n          // reset values and start over once charset has been resolved and 8bit content has been found\n          hasBinary = false;\n          this.headers = {};\n          i = -1; // next iteration has i == 0\n        }\n      }\n      this.fetchContentType();\n      this._processContentTransferEncoding();\n    }\n\n    /**\n     * Parses single header value\n     * @param {String} key Header key\n     * @param {String} value Value for the key\n     * @return {Object} parsed header\n     */\n  }, {\n    key: '_parseHeaderValue',\n    value: function _parseHeaderValue(key, value) {\n      var parsedValue = void 0;\n      var isAddress = false;\n      switch (key) {\n        case 'content-type':\n        case 'content-transfer-encoding':\n        case 'content-disposition':\n        case 'dkim-signature':\n          parsedValue = (0, _emailjsMimeCodec.parseHeaderValue)(value);\n          break;\n        case 'from':\n        case 'sender':\n        case 'to':\n        case 'reply-to':\n        case 'cc':\n        case 'bcc':\n        case 'abuse-reports-to':\n        case 'errors-to':\n        case 'return-path':\n        case 'delivered-to':\n          isAddress = true;\n          parsedValue = {\n            value: [].concat((0, _emailjsAddressparser2.default)(value) || [])\n          };\n          break;\n        case 'date':\n          parsedValue = {\n            value: this._parseDate(value)\n          };\n          break;\n        default:\n          parsedValue = {\n            value: value\n          };\n      }\n      parsedValue.initial = value;\n      this._decodeHeaderCharset(parsedValue, {\n        isAddress: isAddress\n      });\n      return parsedValue;\n    }\n\n    /**\n     * Checks if a date string can be parsed. Falls back replacing timezone\n     * abbrevations with timezone values. Bogus timezones default to UTC.\n     *\n     * @param {String} str Date header\n     * @returns {String} UTC date string if parsing succeeded, otherwise returns input value\n     */\n  }, {\n    key: '_parseDate',\n    value: function _parseDate() {\n      var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var date = new Date(str.trim().replace(/\\b[a-z]+$/i, function (tz) {\n        return _timezones2.default[tz.toUpperCase()] || '+0000';\n      }));\n      return date.toString() !== 'Invalid Date' ? date.toUTCString().replace(/GMT/, '+0000') : str;\n    }\n  }, {\n    key: '_decodeHeaderCharset',\n    value: function _decodeHeaderCharset(parsed) {\n      var _this2 = this;\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        isAddress = _ref.isAddress;\n\n      // decode default value\n      if (typeof parsed.value === 'string') {\n        parsed.value = (0, _emailjsMimeCodec.mimeWordsDecode)(parsed.value);\n      }\n\n      // decode possible params\n      Object.keys(parsed.params || {}).forEach(function (key) {\n        if (typeof parsed.params[key] === 'string') {\n          parsed.params[key] = (0, _emailjsMimeCodec.mimeWordsDecode)(parsed.params[key]);\n        }\n      });\n\n      // decode addresses\n      if (isAddress && Array.isArray(parsed.value)) {\n        parsed.value.forEach(function (addr) {\n          if (addr.name) {\n            addr.name = (0, _emailjsMimeCodec.mimeWordsDecode)(addr.name);\n            if (Array.isArray(addr.group)) {\n              _this2._decodeHeaderCharset({\n                value: addr.group\n              }, {\n                isAddress: true\n              });\n            }\n          }\n        });\n      }\n      return parsed;\n    }\n\n    /**\n     * Parses Content-Type value and selects following actions.\n     */\n  }, {\n    key: 'fetchContentType',\n    value: function fetchContentType() {\n      var defaultValue = (0, _emailjsMimeCodec.parseHeaderValue)('text/plain');\n      this.contentType = (0, _ramda.pathOr)(defaultValue, ['headers', 'content-type', '0'])(this);\n      this.contentType.value = (this.contentType.value || '').toLowerCase().trim();\n      this.contentType.type = this.contentType.value.split('/').shift() || 'text';\n      if (this.contentType.params && this.contentType.params.charset && !this.charset) {\n        this.charset = this.contentType.params.charset;\n      }\n      if (this.contentType.type === 'multipart' && this.contentType.params.boundary) {\n        this.childNodes = [];\n        this._isMultipart = this.contentType.value.split('/').pop() || 'mixed';\n        this._multipartBoundary = this.contentType.params.boundary;\n      }\n\n      /**\n       * For attachment (inline/regular) if charset is not defined and attachment is non-text/*,\n       * then default charset to binary.\n       * Refer to issue: https://github.com/emailjs/emailjs-mime-parser/issues/18\n       */\n      var defaultContentDispositionValue = (0, _emailjsMimeCodec.parseHeaderValue)('');\n      var contentDisposition = (0, _ramda.pathOr)(defaultContentDispositionValue, ['headers', 'content-disposition', '0'])(this);\n      var isAttachment = (contentDisposition.value || '').toLowerCase().trim() === 'attachment';\n      var isInlineAttachment = (contentDisposition.value || '').toLowerCase().trim() === 'inline';\n      if ((isAttachment || isInlineAttachment) && this.contentType.type !== 'text' && !this.charset) {\n        this.charset = 'binary';\n      }\n      if (this.contentType.value === 'message/rfc822' && !isAttachment) {\n        /**\n         * Parse message/rfc822 only if the mime part is not marked with content-disposition: attachment,\n         * otherwise treat it like a regular attachment\n         */\n        this._currentChild = new MimeNode(this.nodeCounter);\n        this.childNodes = [this._currentChild];\n        this._isRfc822 = true;\n      }\n    }\n\n    /**\n     * Parses Content-Transfer-Encoding value to see if the body needs to be converted\n     * before it can be emitted\n     */\n  }, {\n    key: '_processContentTransferEncoding',\n    value: function _processContentTransferEncoding() {\n      var defaultValue = (0, _emailjsMimeCodec.parseHeaderValue)('7bit');\n      this.contentTransferEncoding = (0, _ramda.pathOr)(defaultValue, ['headers', 'content-transfer-encoding', '0'])(this);\n      this.contentTransferEncoding.value = (0, _ramda.pathOr)('', ['contentTransferEncoding', 'value'])(this).toLowerCase().trim();\n    }\n\n    /**\n     * Processes a line in the BODY state. If this is a multipart or rfc822 node,\n     * passes line value to child nodes.\n     *\n     * @param {String} line Entire input line as 'binary' string\n     */\n  }, {\n    key: '_processBodyLine',\n    value: function _processBodyLine(line) {\n      if (this._isMultipart) {\n        if (line === '--' + this._multipartBoundary) {\n          this.bodystructure += line + '\\n';\n          if (this._currentChild) {\n            this._currentChild.finalize();\n          }\n          this._currentChild = new MimeNode(this.nodeCounter);\n          this.childNodes.push(this._currentChild);\n        } else if (line === '--' + this._multipartBoundary + '--') {\n          this.bodystructure += line + '\\n';\n          if (this._currentChild) {\n            this._currentChild.finalize();\n          }\n          this._currentChild = false;\n        } else if (this._currentChild) {\n          this._currentChild.writeLine(line);\n        } else {\n          // Ignore multipart preamble\n        }\n      } else if (this._isRfc822) {\n        this._currentChild.writeLine(line);\n      } else {\n        this._lineCount++;\n        switch (this.contentTransferEncoding.value) {\n          case 'base64':\n            this._bodyBuffer += line;\n            break;\n          case 'quoted-printable':\n            {\n              var curLine = this._lineRemainder + (this._lineCount > 1 ? '\\n' : '') + line;\n              var match = curLine.match(/=[a-f0-9]{0,1}$/i);\n              if (match) {\n                this._lineRemainder = match[0];\n                curLine = curLine.substr(0, curLine.length - this._lineRemainder.length);\n              } else {\n                this._lineRemainder = '';\n              }\n              this._bodyBuffer += curLine;\n              break;\n            }\n          case '7bit':\n          case '8bit':\n          default:\n            this._bodyBuffer += (this._lineCount > 1 ? '\\n' : '') + line;\n            break;\n        }\n      }\n    }\n\n    /**\n     * Emits a chunk of the body\n    */\n  }, {\n    key: '_emitBody',\n    value: function _emitBody() {\n      this._decodeBodyBuffer();\n      if (this._isMultipart || !this._bodyBuffer) {\n        return;\n      }\n      this._processFlowedText();\n      this.content = str2arr(this._bodyBuffer);\n      this._processHtmlText();\n      this._bodyBuffer = '';\n    }\n  }, {\n    key: '_processFlowedText',\n    value: function _processFlowedText() {\n      var isText = /^text\\/(plain|html)$/i.test(this.contentType.value);\n      var isFlowed = /^flowed$/i.test((0, _ramda.pathOr)('', ['contentType', 'params', 'format'])(this));\n      if (!isText || !isFlowed) return;\n      var delSp = /^yes$/i.test(this.contentType.params.delsp);\n      this._bodyBuffer = this._bodyBuffer.split('\\n').reduce(function (previousValue, currentValue) {\n        // remove soft linebreaks after space symbols.\n        // delsp adds spaces to text to be able to fold it.\n        // these spaces can be removed once the text is unfolded\n        var endsWithSpace = / $/.test(previousValue);\n        var isBoundary = /(^|\\n)-- $/.test(previousValue);\n        return (delSp ? previousValue.replace(/[ ]+$/, '') : previousValue) + (endsWithSpace && !isBoundary ? '' : '\\n') + currentValue;\n      }).replace(/^ /gm, ''); // remove whitespace stuffing http://tools.ietf.org/html/rfc3676#section-4.4\n    }\n  }, {\n    key: '_processHtmlText',\n    value: function _processHtmlText() {\n      var contentDisposition = this.headers['content-disposition'] && this.headers['content-disposition'][0] || (0, _emailjsMimeCodec.parseHeaderValue)('');\n      var isHtml = /^text\\/(plain|html)$/i.test(this.contentType.value);\n      var isAttachment = /^attachment$/i.test(contentDisposition.value);\n      if (isHtml && !isAttachment) {\n        if (!this.charset && /^text\\/html$/i.test(this.contentType.value)) {\n          this.charset = this.detectHTMLCharset(this._bodyBuffer);\n        }\n\n        // decode \"binary\" string to an unicode string\n        if (!/^utf[-_]?8$/i.test(this.charset)) {\n          this.content = (0, _emailjsMimeCodec.convert)(str2arr(this._bodyBuffer), this.charset || 'iso-8859-1');\n        } else if (this.contentTransferEncoding.value === 'base64') {\n          this.content = utf8Str2arr(this._bodyBuffer);\n        }\n\n        // override charset for text nodes\n        this.charset = this.contentType.params.charset = 'utf-8';\n      }\n    }\n\n    /**\n     * Detect charset from a html file\n     *\n     * @param {String} html Input HTML\n     * @returns {String} Charset if found or undefined\n     */\n  }, {\n    key: 'detectHTMLCharset',\n    value: function detectHTMLCharset(html) {\n      var charset = void 0,\n        input = void 0;\n      html = html.replace(/\\r?\\n|\\r/g, ' ');\n      var meta = html.match(/<meta\\s+http-equiv=[\"'\\s]*content-type[^>]*?>/i);\n      if (meta) {\n        input = meta[0];\n      }\n      if (input) {\n        charset = input.match(/charset\\s?=\\s?([a-zA-Z\\-_:0-9]*);?/);\n        if (charset) {\n          charset = (charset[1] || '').trim().toLowerCase();\n        }\n      }\n      meta = html.match(/<meta\\s+charset=[\"'\\s]*([^\"'<>/\\s]+)/i);\n      if (!charset && meta) {\n        charset = (meta[1] || '').trim().toLowerCase();\n      }\n      return charset;\n    }\n  }]);\n  return MimeNode;\n}();\nvar str2arr = function str2arr(str) {\n  return new Uint8Array(str.split('').map(function (char) {\n    return char.charCodeAt(0);\n  }));\n};\nvar utf8Str2arr = function utf8Str2arr(str) {\n  return new _textEncoding.TextEncoder('utf-8').encode(str);\n};","map":{"version":3,"names":["parse","_ramda","require","_timezones","_emailjsMimeCodec","_textEncoding","_emailjsAddressparser","MAXIMUM_NUMBER_OF_MIME_NODES","NodeCounter","_classCallCheck","count","Error","chunk","root","MimeNode","lines","_typeof","String","fromCharCode","apply","split","forEach","line","writeLine","finalize","nodeCounter","arguments","length","undefined","bump","header","headers","bodystructure","childNodes","raw","_state","_bodyBuffer","_lineCount","_currentChild","_lineRemainder","_isMultipart","_multipartBoundary","_isRfc822","_processHeaderLine","_processBodyLine","_this","_emitBody","reduce","agg","child","join","contentTransferEncoding","value","base64Decode","charset","replace","m","code","parseInt","_parseHeaders","match","push","hasBinary","i","len","key","shift","trim","toLowerCase","decode","convert","str2arr","concat","_parseHeaderValue","params","fetchContentType","_processContentTransferEncoding","parsedValue","isAddress","parseHeaderValue","_emailjsAddressparser2","default","_parseDate","initial","_decodeHeaderCharset","str","date","Date","tz","_timezones2","toUpperCase","toString","toUTCString","parsed","_this2","_ref","mimeWordsDecode","Object","keys","Array","isArray","addr","name","group","defaultValue","contentType","pathOr","type","boundary","pop","defaultContentDispositionValue","contentDisposition","isAttachment","isInlineAttachment","curLine","substr","_decodeBodyBuffer","_processFlowedText","content","_processHtmlText","isText","test","isFlowed","delSp","delsp","previousValue","currentValue","endsWithSpace","isBoundary","isHtml","detectHTMLCharset","utf8Str2arr","html","input","meta","Uint8Array","map","char","charCodeAt","TextEncoder","encode"],"sources":["/home/vaslyb/Desktop/witheflow/annotator/src/node_modules/emailjs-mime-parser/src/mimeparser.js"],"sourcesContent":["import { pathOr } from 'ramda'\nimport timezone from './timezones'\nimport { decode, base64Decode, convert, parseHeaderValue, mimeWordsDecode } from 'emailjs-mime-codec'\nimport { TextEncoder } from 'text-encoding'\nimport parseAddress from 'emailjs-addressparser'\n\n/*\n * Counts MIME nodes to prevent memory exhaustion attacks (CWE-400)\n * see: https://snyk.io/vuln/npm:emailjs-mime-parser:20180625\n */\nconst MAXIMUM_NUMBER_OF_MIME_NODES = 999\nexport class NodeCounter {\n  constructor () {\n    this.count = 0\n  }\n  bump () {\n    if (++this.count > MAXIMUM_NUMBER_OF_MIME_NODES) {\n      throw new Error('Maximum number of MIME nodes exceeded!')\n    }\n  }\n}\n\nexport default function parse (chunk) {\n  const root = new MimeNode(new NodeCounter())\n  const lines = (typeof chunk === 'object' ? String.fromCharCode.apply(null, chunk) : chunk).split(/\\r?\\n/g)\n  lines.forEach(line => root.writeLine(line))\n  root.finalize()\n  return root\n}\n\nexport class MimeNode {\n  constructor (nodeCounter = new NodeCounter()) {\n    this.nodeCounter = nodeCounter\n    this.nodeCounter.bump()\n\n    this.header = [] // An array of unfolded header lines\n    this.headers = {} // An object that holds header key=value pairs\n    this.bodystructure = ''\n    this.childNodes = [] // If this is a multipart or message/rfc822 mime part, the value will be converted to array and hold all child nodes for this node\n    this.raw = '' // Stores the raw content of this node\n\n    this._state = 'HEADER' // Current state, always starts out with HEADER\n    this._bodyBuffer = '' // Body buffer\n    this._lineCount = 0 // Line counter bor the body part\n    this._currentChild = false // Active child node (if available)\n    this._lineRemainder = '' // Remainder string when dealing with base64 and qp values\n    this._isMultipart = false // Indicates if this is a multipart node\n    this._multipartBoundary = false // Stores boundary value for current multipart node\n    this._isRfc822 = false // Indicates if this is a message/rfc822 node\n  }\n\n  writeLine (line) {\n    this.raw += (this.raw ? '\\n' : '') + line\n\n    if (this._state === 'HEADER') {\n      this._processHeaderLine(line)\n    } else if (this._state === 'BODY') {\n      this._processBodyLine(line)\n    }\n  }\n\n  finalize () {\n    if (this._isRfc822) {\n      this._currentChild.finalize()\n    } else {\n      this._emitBody()\n    }\n\n    this.bodystructure = this.childNodes\n      .reduce((agg, child) => agg + '--' + this._multipartBoundary + '\\n' + child.bodystructure, this.header.join('\\n') + '\\n\\n') +\n      (this._multipartBoundary ? '--' + this._multipartBoundary + '--\\n' : '')\n  }\n\n  _decodeBodyBuffer () {\n    switch (this.contentTransferEncoding.value) {\n      case 'base64':\n        this._bodyBuffer = base64Decode(this._bodyBuffer, this.charset)\n        break\n      case 'quoted-printable': {\n        this._bodyBuffer = this._bodyBuffer\n          .replace(/=(\\r?\\n|$)/g, '')\n          .replace(/=([a-f0-9]{2})/ig, (m, code) => String.fromCharCode(parseInt(code, 16)))\n        break\n      }\n    }\n  }\n\n  /**\n   * Processes a line in the HEADER state. It the line is empty, change state to BODY\n   *\n   * @param {String} line Entire input line as 'binary' string\n   */\n  _processHeaderLine (line) {\n    if (!line) {\n      this._parseHeaders()\n      this.bodystructure += this.header.join('\\n') + '\\n\\n'\n      this._state = 'BODY'\n      return\n    }\n\n    if (line.match(/^\\s/) && this.header.length) {\n      this.header[this.header.length - 1] += '\\n' + line\n    } else {\n      this.header.push(line)\n    }\n  }\n\n  /**\n   * Joins folded header lines and calls Content-Type and Transfer-Encoding processors\n   */\n  _parseHeaders () {\n    for (let hasBinary = false, i = 0, len = this.header.length; i < len; i++) {\n      let value = this.header[i].split(':')\n      const key = (value.shift() || '').trim().toLowerCase()\n      value = (value.join(':') || '').replace(/\\n/g, '').trim()\n\n      if (value.match(/[\\u0080-\\uFFFF]/)) {\n        if (!this.charset) {\n          hasBinary = true\n        }\n        // use default charset at first and if the actual charset is resolved, the conversion is re-run\n        value = decode(convert(str2arr(value), this.charset || 'iso-8859-1'))\n      }\n\n      this.headers[key] = (this.headers[key] || []).concat([this._parseHeaderValue(key, value)])\n\n      if (!this.charset && key === 'content-type') {\n        this.charset = this.headers[key][this.headers[key].length - 1].params.charset\n      }\n\n      if (hasBinary && this.charset) {\n        // reset values and start over once charset has been resolved and 8bit content has been found\n        hasBinary = false\n        this.headers = {}\n        i = -1 // next iteration has i == 0\n      }\n    }\n\n    this.fetchContentType()\n    this._processContentTransferEncoding()\n  }\n\n  /**\n   * Parses single header value\n   * @param {String} key Header key\n   * @param {String} value Value for the key\n   * @return {Object} parsed header\n   */\n  _parseHeaderValue (key, value) {\n    let parsedValue\n    let isAddress = false\n\n    switch (key) {\n      case 'content-type':\n      case 'content-transfer-encoding':\n      case 'content-disposition':\n      case 'dkim-signature':\n        parsedValue = parseHeaderValue(value)\n        break\n      case 'from':\n      case 'sender':\n      case 'to':\n      case 'reply-to':\n      case 'cc':\n      case 'bcc':\n      case 'abuse-reports-to':\n      case 'errors-to':\n      case 'return-path':\n      case 'delivered-to':\n        isAddress = true\n        parsedValue = {\n          value: [].concat(parseAddress(value) || [])\n        }\n        break\n      case 'date':\n        parsedValue = {\n          value: this._parseDate(value)\n        }\n        break\n      default:\n        parsedValue = {\n          value: value\n        }\n    }\n    parsedValue.initial = value\n\n    this._decodeHeaderCharset(parsedValue, { isAddress })\n\n    return parsedValue\n  }\n\n  /**\n   * Checks if a date string can be parsed. Falls back replacing timezone\n   * abbrevations with timezone values. Bogus timezones default to UTC.\n   *\n   * @param {String} str Date header\n   * @returns {String} UTC date string if parsing succeeded, otherwise returns input value\n   */\n  _parseDate (str = '') {\n    const date = new Date(str.trim().replace(/\\b[a-z]+$/i, tz => timezone[tz.toUpperCase()] || '+0000'))\n    return (date.toString() !== 'Invalid Date') ? date.toUTCString().replace(/GMT/, '+0000') : str\n  }\n\n  _decodeHeaderCharset (parsed, { isAddress } = {}) {\n    // decode default value\n    if (typeof parsed.value === 'string') {\n      parsed.value = mimeWordsDecode(parsed.value)\n    }\n\n    // decode possible params\n    Object.keys(parsed.params || {}).forEach(function (key) {\n      if (typeof parsed.params[key] === 'string') {\n        parsed.params[key] = mimeWordsDecode(parsed.params[key])\n      }\n    })\n\n    // decode addresses\n    if (isAddress && Array.isArray(parsed.value)) {\n      parsed.value.forEach(addr => {\n        if (addr.name) {\n          addr.name = mimeWordsDecode(addr.name)\n          if (Array.isArray(addr.group)) {\n            this._decodeHeaderCharset({ value: addr.group }, { isAddress: true })\n          }\n        }\n      })\n    }\n\n    return parsed\n  }\n\n  /**\n   * Parses Content-Type value and selects following actions.\n   */\n  fetchContentType () {\n    const defaultValue = parseHeaderValue('text/plain')\n    this.contentType = pathOr(defaultValue, ['headers', 'content-type', '0'])(this)\n    this.contentType.value = (this.contentType.value || '').toLowerCase().trim()\n    this.contentType.type = (this.contentType.value.split('/').shift() || 'text')\n\n    if (this.contentType.params && this.contentType.params.charset && !this.charset) {\n      this.charset = this.contentType.params.charset\n    }\n\n    if (this.contentType.type === 'multipart' && this.contentType.params.boundary) {\n      this.childNodes = []\n      this._isMultipart = (this.contentType.value.split('/').pop() || 'mixed')\n      this._multipartBoundary = this.contentType.params.boundary\n    }\n\n    /**\n     * For attachment (inline/regular) if charset is not defined and attachment is non-text/*,\n     * then default charset to binary.\n     * Refer to issue: https://github.com/emailjs/emailjs-mime-parser/issues/18\n     */\n    const defaultContentDispositionValue = parseHeaderValue('')\n    const contentDisposition = pathOr(defaultContentDispositionValue, ['headers', 'content-disposition', '0'])(this)\n    const isAttachment = (contentDisposition.value || '').toLowerCase().trim() === 'attachment'\n    const isInlineAttachment = (contentDisposition.value || '').toLowerCase().trim() === 'inline'\n    if ((isAttachment || isInlineAttachment) && this.contentType.type !== 'text' && !this.charset) {\n      this.charset = 'binary'\n    }\n\n    if (this.contentType.value === 'message/rfc822' && !isAttachment) {\n      /**\n       * Parse message/rfc822 only if the mime part is not marked with content-disposition: attachment,\n       * otherwise treat it like a regular attachment\n       */\n      this._currentChild = new MimeNode(this.nodeCounter)\n      this.childNodes = [this._currentChild]\n      this._isRfc822 = true\n    }\n  }\n\n  /**\n   * Parses Content-Transfer-Encoding value to see if the body needs to be converted\n   * before it can be emitted\n   */\n  _processContentTransferEncoding () {\n    const defaultValue = parseHeaderValue('7bit')\n    this.contentTransferEncoding = pathOr(defaultValue, ['headers', 'content-transfer-encoding', '0'])(this)\n    this.contentTransferEncoding.value = pathOr('', ['contentTransferEncoding', 'value'])(this).toLowerCase().trim()\n  }\n\n  /**\n   * Processes a line in the BODY state. If this is a multipart or rfc822 node,\n   * passes line value to child nodes.\n   *\n   * @param {String} line Entire input line as 'binary' string\n   */\n  _processBodyLine (line) {\n    if (this._isMultipart) {\n      if (line === '--' + this._multipartBoundary) {\n        this.bodystructure += line + '\\n'\n        if (this._currentChild) {\n          this._currentChild.finalize()\n        }\n        this._currentChild = new MimeNode(this.nodeCounter)\n        this.childNodes.push(this._currentChild)\n      } else if (line === '--' + this._multipartBoundary + '--') {\n        this.bodystructure += line + '\\n'\n        if (this._currentChild) {\n          this._currentChild.finalize()\n        }\n        this._currentChild = false\n      } else if (this._currentChild) {\n        this._currentChild.writeLine(line)\n      } else {\n        // Ignore multipart preamble\n      }\n    } else if (this._isRfc822) {\n      this._currentChild.writeLine(line)\n    } else {\n      this._lineCount++\n\n      switch (this.contentTransferEncoding.value) {\n        case 'base64':\n          this._bodyBuffer += line\n          break\n        case 'quoted-printable': {\n          let curLine = this._lineRemainder + (this._lineCount > 1 ? '\\n' : '') + line\n          const match = curLine.match(/=[a-f0-9]{0,1}$/i)\n          if (match) {\n            this._lineRemainder = match[0]\n            curLine = curLine.substr(0, curLine.length - this._lineRemainder.length)\n          } else {\n            this._lineRemainder = ''\n          }\n          this._bodyBuffer += curLine\n          break\n        }\n        case '7bit':\n        case '8bit':\n        default:\n          this._bodyBuffer += (this._lineCount > 1 ? '\\n' : '') + line\n          break\n      }\n    }\n  }\n\n  /**\n   * Emits a chunk of the body\n  */\n  _emitBody () {\n    this._decodeBodyBuffer()\n    if (this._isMultipart || !this._bodyBuffer) {\n      return\n    }\n\n    this._processFlowedText()\n    this.content = str2arr(this._bodyBuffer)\n    this._processHtmlText()\n    this._bodyBuffer = ''\n  }\n\n  _processFlowedText () {\n    const isText = /^text\\/(plain|html)$/i.test(this.contentType.value)\n    const isFlowed = /^flowed$/i.test(pathOr('', ['contentType', 'params', 'format'])(this))\n    if (!isText || !isFlowed) return\n\n    const delSp = /^yes$/i.test(this.contentType.params.delsp)\n    this._bodyBuffer = this._bodyBuffer.split('\\n')\n      .reduce(function (previousValue, currentValue) {\n        // remove soft linebreaks after space symbols.\n        // delsp adds spaces to text to be able to fold it.\n        // these spaces can be removed once the text is unfolded\n        const endsWithSpace = / $/.test(previousValue)\n        const isBoundary = /(^|\\n)-- $/.test(previousValue)\n        return (delSp ? previousValue.replace(/[ ]+$/, '') : previousValue) + ((endsWithSpace && !isBoundary) ? '' : '\\n') + currentValue\n      })\n      .replace(/^ /gm, '') // remove whitespace stuffing http://tools.ietf.org/html/rfc3676#section-4.4\n  }\n\n  _processHtmlText () {\n    const contentDisposition = (this.headers['content-disposition'] && this.headers['content-disposition'][0]) || parseHeaderValue('')\n    const isHtml = /^text\\/(plain|html)$/i.test(this.contentType.value)\n    const isAttachment = /^attachment$/i.test(contentDisposition.value)\n    if (isHtml && !isAttachment) {\n      if (!this.charset && /^text\\/html$/i.test(this.contentType.value)) {\n        this.charset = this.detectHTMLCharset(this._bodyBuffer)\n      }\n\n      // decode \"binary\" string to an unicode string\n      if (!/^utf[-_]?8$/i.test(this.charset)) {\n        this.content = convert(str2arr(this._bodyBuffer), this.charset || 'iso-8859-1')\n      } else if (this.contentTransferEncoding.value === 'base64') {\n        this.content = utf8Str2arr(this._bodyBuffer)\n      }\n\n      // override charset for text nodes\n      this.charset = this.contentType.params.charset = 'utf-8'\n    }\n  }\n\n  /**\n   * Detect charset from a html file\n   *\n   * @param {String} html Input HTML\n   * @returns {String} Charset if found or undefined\n   */\n  detectHTMLCharset (html) {\n    let charset, input\n\n    html = html.replace(/\\r?\\n|\\r/g, ' ')\n    let meta = html.match(/<meta\\s+http-equiv=[\"'\\s]*content-type[^>]*?>/i)\n    if (meta) {\n      input = meta[0]\n    }\n\n    if (input) {\n      charset = input.match(/charset\\s?=\\s?([a-zA-Z\\-_:0-9]*);?/)\n      if (charset) {\n        charset = (charset[1] || '').trim().toLowerCase()\n      }\n    }\n\n    meta = html.match(/<meta\\s+charset=[\"'\\s]*([^\"'<>/\\s]+)/i)\n    if (!charset && meta) {\n      charset = (meta[1] || '').trim().toLowerCase()\n    }\n\n    return charset\n  }\n}\n\nconst str2arr = str => new Uint8Array(str.split('').map(char => char.charCodeAt(0)))\nconst utf8Str2arr = str => new TextEncoder('utf-8').encode(str)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}