{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nexports.default = parse;\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    \"Name <address@domain>\"\n *\n * will be converted to\n *\n *     [{name: \"Name\", address: \"address@domain\"}]\n *\n * @param {String} str Address field\n * @return {Array} An array of address objects\n */\nfunction parse(str) {\n  var tokenizer = new Tokenizer(str);\n  var tokens = tokenizer.tokenize();\n  var addresses = [];\n  var address = [];\n  var parsedAddresses = [];\n  tokens.forEach(function (token) {\n    if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n      if (address.length) {\n        addresses.push(address);\n      }\n      address = [];\n    } else {\n      address.push(token);\n    }\n  });\n  if (address.length) {\n    addresses.push(address);\n  }\n  addresses.forEach(function (address) {\n    address = _handleAddress(address);\n    if (address.length) {\n      parsedAddresses = parsedAddresses.concat(address);\n    }\n  });\n  return parsedAddresses;\n}\n;\n\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @return {Object} Address object\n */\nfunction _handleAddress(tokens) {\n  var isGroup = false;\n  var state = 'text';\n  var address = void 0;\n  var addresses = [];\n  var data = {\n    address: [],\n    comment: [],\n    group: [],\n    text: []\n\n    // Filter out <addresses>, (comments) and regular text\n  };\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    var token = tokens[i];\n    if (token.type === 'operator') {\n      switch (token.value) {\n        case '<':\n          state = 'address';\n          break;\n        case '(':\n          state = 'comment';\n          break;\n        case ':':\n          state = 'group';\n          isGroup = true;\n          break;\n        default:\n          state = 'text';\n      }\n    } else {\n      if (token.value) {\n        data[state].push(token.value);\n      }\n    }\n  }\n\n  // If there is no text but a comment, replace the two\n  if (!data.text.length && data.comment.length) {\n    data.text = data.comment;\n    data.comment = [];\n  }\n  if (isGroup) {\n    // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n    data.text = data.text.join(' ');\n    addresses.push({\n      name: data.text || address && address.name,\n      group: data.group.length ? parse(data.group.join(',')) : []\n    });\n  } else {\n    // If no address was found, try to detect one from regular text\n    if (!data.address.length && data.text.length) {\n      for (var _i = data.text.length - 1; _i >= 0; _i--) {\n        if (data.text[_i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n          data.address = data.text.splice(_i, 1);\n          break;\n        }\n      }\n      var _regexHandler = function _regexHandler(address) {\n        if (!data.address.length) {\n          data.address = [address.trim()];\n          return ' ';\n        } else {\n          return address;\n        }\n      };\n\n      // still no address\n      if (!data.address.length) {\n        for (var _i2 = data.text.length - 1; _i2 >= 0; _i2--) {\n          data.text[_i2] = data.text[_i2].replace(/\\s*\\b[^@\\s]+@[^@\\s]+\\b\\s*/, _regexHandler).trim();\n          if (data.address.length) {\n            break;\n          }\n        }\n      }\n    }\n\n    // If there's still is no text but a comment exixts, replace the two\n    if (!data.text.length && data.comment.length) {\n      data.text = data.comment;\n      data.comment = [];\n    }\n\n    // Keep only the last address occurence, push others to regular text\n    if (data.address.length > 1) {\n      var _address = data.address.pop();\n      data.text = data.text.concat(data.address.map(function (fakeAddress) {\n        return '<' + fakeAddress + '>';\n      }));\n      data.address = [_address];\n    }\n\n    // Join values with spaces\n    data.text = data.text.join(' ');\n    data.address = data.address.join(' ');\n    if (!data.address && isGroup) {\n      return [];\n    } else {\n      address = {\n        address: data.address || data.text || '',\n        name: data.text || data.address || ''\n      };\n      if (address.address === address.name) {\n        if ((address.address || '').match(/@/)) {\n          address.name = '';\n        } else {\n          address.address = '';\n        }\n      }\n      addresses.push(address);\n    }\n  }\n  return addresses;\n}\n;\n\n/*\n * Operator tokens and which tokens are expected to end the sequence\n */\nvar OPERATORS = {\n  '\"': '\"',\n  '(': ')',\n  '<': '>',\n  ',': '',\n  // Groups are ended by semicolons\n  ':': ';',\n  // Semicolons are not a legal delimiter per the RFC2822 grammar other\n  // than for terminating a group, but they are also not valid for any\n  // other use in this context.  Given that some mail clients have\n  // historically allowed the semicolon as a delimiter equivalent to the\n  // comma in their UI, it makes sense to treat them the same as a comma\n  // when used outside of a group.\n  ';': ''\n\n  /**\n   * Creates a Tokenizer object for tokenizing address field strings\n   *\n   * @constructor\n   * @param {String} str Address field string\n   */\n};\nvar Tokenizer = function () {\n  function Tokenizer(str) {\n    _classCallCheck(this, Tokenizer);\n    this.str = (str || '').toString();\n    this.operatorCurrent = '';\n    this.operatorExpecting = '';\n    this.node = null;\n    this.escaped = false;\n    this.list = [];\n  }\n\n  /**\n   * Tokenizes the original input string\n   *\n   * @return {Array} An array of operator|text tokens\n   */\n\n  _createClass(Tokenizer, [{\n    key: 'tokenize',\n    value: function tokenize() {\n      var chr = void 0;\n      var list = [];\n      for (var i = 0, len = this.str.length; i < len; i++) {\n        chr = this.str.charAt(i);\n        this.checkChar(chr);\n      }\n      this.list.forEach(function (node) {\n        node.value = (node.value || '').toString().trim();\n        if (node.value) {\n          list.push(node);\n        }\n      });\n      return list;\n    }\n\n    /**\n     * Checks if a character is an operator or text and acts accordingly\n     *\n     * @param {String} chr Character from the address field\n     */\n  }, {\n    key: 'checkChar',\n    value: function checkChar(chr) {\n      if ((chr in OPERATORS || chr === '\\\\') && this.escaped) {\n        this.escaped = false;\n      } else if (this.operatorExpecting && chr === this.operatorExpecting) {\n        this.node = {\n          type: 'operator',\n          value: chr\n        };\n        this.list.push(this.node);\n        this.node = null;\n        this.operatorExpecting = '';\n        this.escaped = false;\n        return;\n      } else if (!this.operatorExpecting && chr in OPERATORS) {\n        this.node = {\n          type: 'operator',\n          value: chr\n        };\n        this.list.push(this.node);\n        this.node = null;\n        this.operatorExpecting = OPERATORS[chr];\n        this.escaped = false;\n        return;\n      }\n      if (!this.escaped && chr === '\\\\') {\n        this.escaped = true;\n        return;\n      }\n      if (!this.node) {\n        this.node = {\n          type: 'text',\n          value: ''\n        };\n        this.list.push(this.node);\n      }\n      if (this.escaped && chr !== '\\\\') {\n        this.node.value += '\\\\';\n      }\n      this.node.value += chr;\n      this.escaped = false;\n    }\n  }]);\n  return Tokenizer;\n}();","map":{"version":3,"names":["parse","str","tokenizer","Tokenizer","tokens","tokenize","addresses","address","parsedAddresses","forEach","token","type","value","length","push","_handleAddress","concat","isGroup","state","data","comment","group","text","i","len","join","name","_i","match","splice","_regexHandler","trim","_i2","replace","_address","pop","map","fakeAddress","OPERATORS","_classCallCheck","toString","operatorCurrent","operatorExpecting","node","escaped","list","chr","charAt","checkChar"],"sources":["/home/vaslyb/Desktop/witheflow/annotator/src/node_modules/emailjs-addressparser/src/addressparser.js"],"sourcesContent":["/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    \"Name <address@domain>\"\n *\n * will be converted to\n *\n *     [{name: \"Name\", address: \"address@domain\"}]\n *\n * @param {String} str Address field\n * @return {Array} An array of address objects\n */\nexport default function parse (str) {\n  const tokenizer = new Tokenizer(str)\n  const tokens = tokenizer.tokenize()\n\n  const addresses = []\n  let address = []\n  let parsedAddresses = []\n\n  tokens.forEach(function (token) {\n    if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n      if (address.length) {\n        addresses.push(address)\n      }\n      address = []\n    } else {\n      address.push(token)\n    }\n  })\n\n  if (address.length) {\n    addresses.push(address)\n  }\n\n  addresses.forEach(function (address) {\n    address = _handleAddress(address)\n    if (address.length) {\n      parsedAddresses = parsedAddresses.concat(address)\n    }\n  })\n\n  return parsedAddresses\n};\n\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @return {Object} Address object\n */\nfunction _handleAddress (tokens) {\n  let isGroup = false\n  let state = 'text'\n  let address\n  const addresses = []\n  const data = {\n    address: [],\n    comment: [],\n    group: [],\n    text: []\n  }\n\n  // Filter out <addresses>, (comments) and regular text\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    const token = tokens[i]\n\n    if (token.type === 'operator') {\n      switch (token.value) {\n        case '<':\n          state = 'address'\n          break\n        case '(':\n          state = 'comment'\n          break\n        case ':':\n          state = 'group'\n          isGroup = true\n          break\n        default:\n          state = 'text'\n      }\n    } else {\n      if (token.value) {\n        data[state].push(token.value)\n      }\n    }\n  }\n\n  // If there is no text but a comment, replace the two\n  if (!data.text.length && data.comment.length) {\n    data.text = data.comment\n    data.comment = []\n  }\n\n  if (isGroup) {\n    // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n    data.text = data.text.join(' ')\n    addresses.push({\n      name: data.text || (address && address.name),\n      group: data.group.length ? parse(data.group.join(',')) : []\n    })\n  } else {\n    // If no address was found, try to detect one from regular text\n    if (!data.address.length && data.text.length) {\n      for (let i = data.text.length - 1; i >= 0; i--) {\n        if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n          data.address = data.text.splice(i, 1)\n          break\n        }\n      }\n\n      var _regexHandler = function (address) {\n        if (!data.address.length) {\n          data.address = [address.trim()]\n          return ' '\n        } else {\n          return address\n        }\n      }\n\n      // still no address\n      if (!data.address.length) {\n        for (let i = data.text.length - 1; i >= 0; i--) {\n          data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^@\\s]+\\b\\s*/, _regexHandler).trim()\n          if (data.address.length) {\n            break\n          }\n        }\n      }\n    }\n\n    // If there's still is no text but a comment exixts, replace the two\n    if (!data.text.length && data.comment.length) {\n      data.text = data.comment\n      data.comment = []\n    }\n\n    // Keep only the last address occurence, push others to regular text\n    if (data.address.length > 1) {\n      const address = data.address.pop()\n      data.text = data.text.concat(data.address.map(fakeAddress => `<${fakeAddress}>`))\n      data.address = [address]\n    }\n\n    // Join values with spaces\n    data.text = data.text.join(' ')\n    data.address = data.address.join(' ')\n\n    if (!data.address && isGroup) {\n      return []\n    } else {\n      address = {\n        address: data.address || data.text || '',\n        name: data.text || data.address || ''\n      }\n\n      if (address.address === address.name) {\n        if ((address.address || '').match(/@/)) {\n          address.name = ''\n        } else {\n          address.address = ''\n        }\n      }\n\n      addresses.push(address)\n    }\n  }\n\n  return addresses\n};\n\n/*\n * Operator tokens and which tokens are expected to end the sequence\n */\nconst OPERATORS = {\n  '\"': '\"',\n  '(': ')',\n  '<': '>',\n  ',': '',\n  // Groups are ended by semicolons\n  ':': ';',\n  // Semicolons are not a legal delimiter per the RFC2822 grammar other\n  // than for terminating a group, but they are also not valid for any\n  // other use in this context.  Given that some mail clients have\n  // historically allowed the semicolon as a delimiter equivalent to the\n  // comma in their UI, it makes sense to treat them the same as a comma\n  // when used outside of a group.\n  ';': ''\n}\n\n/**\n * Creates a Tokenizer object for tokenizing address field strings\n *\n * @constructor\n * @param {String} str Address field string\n */\nclass Tokenizer {\n  constructor (str) {\n    this.str = (str || '').toString()\n    this.operatorCurrent = ''\n    this.operatorExpecting = ''\n    this.node = null\n    this.escaped = false\n    this.list = []\n  }\n\n  /**\n   * Tokenizes the original input string\n   *\n   * @return {Array} An array of operator|text tokens\n   */\n  tokenize () {\n    let chr\n    let list = []\n    for (var i = 0, len = this.str.length; i < len; i++) {\n      chr = this.str.charAt(i)\n      this.checkChar(chr)\n    }\n\n    this.list.forEach(function (node) {\n      node.value = (node.value || '').toString().trim()\n      if (node.value) {\n        list.push(node)\n      }\n    })\n\n    return list\n  }\n\n  /**\n   * Checks if a character is an operator or text and acts accordingly\n   *\n   * @param {String} chr Character from the address field\n   */\n  checkChar (chr) {\n    if ((chr in OPERATORS || chr === '\\\\') && this.escaped) {\n      this.escaped = false\n    } else if (this.operatorExpecting && chr === this.operatorExpecting) {\n      this.node = {\n        type: 'operator',\n        value: chr\n      }\n      this.list.push(this.node)\n      this.node = null\n      this.operatorExpecting = ''\n      this.escaped = false\n      return\n    } else if (!this.operatorExpecting && chr in OPERATORS) {\n      this.node = {\n        type: 'operator',\n        value: chr\n      }\n      this.list.push(this.node)\n      this.node = null\n      this.operatorExpecting = OPERATORS[chr]\n      this.escaped = false\n      return\n    }\n\n    if (!this.escaped && chr === '\\\\') {\n      this.escaped = true\n      return\n    }\n\n    if (!this.node) {\n      this.node = {\n        type: 'text',\n        value: ''\n      }\n      this.list.push(this.node)\n    }\n\n    if (this.escaped && chr !== '\\\\') {\n      this.node.value += '\\\\'\n    }\n\n    this.node.value += chr\n    this.escaped = false\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}